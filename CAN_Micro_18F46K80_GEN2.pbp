'************************************************************************
'Copyright (c) 2016 - OpenMotics <info@openmotics.com>

'This file is part of OpenMotics.

'OpenMotics is free software: you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation, either version 3 of the License, or
'(at your option) any later version.

'OpenMotics is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.

'You should have received a copy of the GNU General Public License
'along with OpenMotics.  If not, see <http://www.gnu.org/licenses/>.
'************************************************************************

'Firmware to be used with the OpenMotics micro CAN Module

'Written in Pic Basic Pro 2.6 however it should be compatible with Pic Basic Pro 3.0 but this is not yet tested
'Interrupt system of Darrel Taylor is used see http://darreltaylor.com/DT_INTS-18/home.html
'For more information see wiki.openmotics.com


@ CONFIG SOSCSEL=DIG
@ CONFIG CANMX=PORTC


DEFINE OSC 64       'Use the internal Xtal

version con 1
firmware con 5
built con 7

include "PIC18CAN.bas"

DEFINE  USE_LOWPRIORITY  1
define  NO_CLRWDT 1
INCLUDE "DT_INTS-18F45K80.bas" ; Base Interrupt System
INCLUDE "ReEnterPBP-18.bas"    ; Include if using PBP interrupts
INCLUDE "ReEnterPBP-18LP.bas"  ; Include if using Low Pr. PBP INTS

'--------40Mhz (external xtal 10Mhz PLL to 40Mhz)------------------
' For PBP2.6 (not for 3.0) please modify 18F45K80.inc (in directory /PBP)
' Modification: CONFIG FOSC = HS1
'DEFINE OSC 40
'OSCCON.0=0 'external oscillator
'OSCCON.1=0
'OSCTUNE.6=1 'PLL enabled
'BAUDCON1.5=0 'receive data is not inverted
'BAUDCON1.3=1 'BRG16=1
'BAUDCON1.4=0 'idle state for Txd is 1
'SPBRGH1 = 0  '115200 baud
'SPBRG1 = 86
'RCSTA1 = %00010000
'TXSTA1 = %00000100
'BAUDCON2.5=0 'receive data is not inverted
'BAUDCON2.3=1 'BRG16=1
'BAUDCON2.4=0 'idle state for Txd is 1
'SPBRGH2 = 0  '115200 baud
'SPBRG2 = 86
'RCSTA2 = %00010000
'TXSTA2 = %00000100
'T0CON=%10000001               ; T0 = 16-bit, 1:4 Prescaler
'T2CON=%00011111               ; Interrupt every 1.6ms

'--------64Mhz (external xtal 16Mhz PLL to 40Mhz)----------------------------------
' For PBP2.6 (not for 3.0) please modify 18F45K80.inc (in directory /PBP)
' Modification: CONFIG FOSC = HS1

OSCCON.0=0 'external oscillator
OSCCON.1=0
OSCTUNE.6=1 'PLL enabled
BAUDCON1.5=0 'receive data is not inverted
BAUDCON1.3=1 'BRG16=1
BAUDCON1.4=0 'idle state for Txd is 1
SPBRGH1 = 0  '115200 baud
SPBRG1 = 138
RCSTA1 = %00010000
TXSTA1 = %00000100
BAUDCON2.5=0 'receive data is not inverted
BAUDCON2.3=1 'BRG16=1
BAUDCON2.4=0 'idle state for Txd is 1
SPBRGH2 = 0  '115200 baud
SPBRG2 = 138
RCSTA2 = %00000000
TXSTA2 = %00000100
T0CON=%00000011               ; T0 = 16-bit, 1:16 Prescaler
T1CON=%00111010               ; 16 bit, timer enabled, 1:8 prescale
T2CON=%01111111               ; Interrupt every 2ms
T4CON=%00000101
'INTCON2.7=0                   ; Weak pull-up for PORTB
'Also modify Baudrate generator i2c (check_i2c_error, initialization)
'Also modify CAN parameters (init_can)

''--------16Mhz (internal xtal}----------------------------------
'' For PBP2.6 (not for 3.0) please modify 18F45K80.inc (in directory /PBP)
'' Modification: CONFIG FOSC = INTIO2
'DEFINE OSC 16       'Use the internal Xtal
'OSCCON.0=0
'OSCCON.1=1 'Internal Oscillator
'OSCCON.6=1 'Internal oscillator at 16 Mhz
'OSCCON.5=1
'OSCCON.4=1
'OSCTUNE.6=0 'PLL disabled
'BAUDCON1.5=0 'receive data is not inverted
'BAUDCON1.3=1 'BRG16=1
'BAUDCON1.4=0 'idle state for Txd is 1
'SPBRGH1 = 0  '115200 baud
'SPBRG1 = 34
'RCSTA1 = %00010000
'TXSTA1 = %00000100
'BAUDCON2.5=0 'receive data is not inverted
'BAUDCON2.3=1 'BRG16=1
'BAUDCON2.4=0 'idle state for Txd is 1
'SPBRGH2 = 0  '115200 baud
'SPBRG2 = 34
'RCSTA2 = %00000000
'TXSTA2 = %00000100
'T0CON=%00000011               ; T0 = 16-bit, 1:16 Prescaler
'T2CON=%00001111               ; Interrupt every 2ms
''INTCON2.7=0                   ; Weak pull-up for PORTB
'Also modify Baudrate generator i2c (check_i2c_error, initialization)
'Also modify CAN parameters (init_can)

'----------Config for Testprint--------------------------------
'TRISB=%11101011
'ANCON0=%00000000   'All ports configured as digital ports
'ANCON1=%00000000   'All ports configured as digital ports
'CCP2CON=0
'RS485_mode var    PORTC.5        ' Mode for RS485 chip (send or receive)
'low RS485_mode
'input PORTC.7
'output PORTC.6
'LED_1      VAR  PORTC.1   ' Led
'high led_1
'LED_2      var  PORTC.2
'high led_2
'LED_ST     var  PORTD.4
'high led_ST
''Leds and input on the final print
'LED_SW_2   var  PORTC.3
'high LED_SW_2
'LED_SW_1   var  PORTB.4
'high LED_SW_1
'input PORTD.0
'Input1     var  PORTD.0
'INPUT PORTD.1
'Input2     var  PORTD.1
'input1old var bit
'input2old var bit
'input1old=1
'input2old=1
'Also modify Baudrate generator i2c (check_i2c_error, initialization)
'Also modify CAN parameters (init_can)

'----------Config for button print-----------------------------
'The CAN module uses the RB2/CANTX and RB3/CANRX pins to interface with the CAN bus. 
'The CANTX and CANRX pins can be placed on alternate
'I/O pins by setting the CANMX (CONFIG3H<0>) Configuration bit which is done on the button print
'Please make sure CONFIG3H<0> is set correctly
ANCON0=%00000000   'All ports configured as digital ports
ANCON1=%00000000   'All ports configured as digital ports
TRISA=%11111111
TRISB=%11001100
TRISC=%10011000
TRISD=%01100000
TRISE=%11111000

SDA        var  PORTC.4
SCL        var  PORTC.3
onewire    var  PORTB.0
onewire2   var  PORTB.1
LedGreen   var  PORTC.0
LedBlue    VAR  PORTC.1
LedRed     var  PORTC.2
Red        var  byte     'Value Red for status led
Green      var  byte     'Value Green for status led
Blue       var  byte     'Value Blue for status led
RedOld     var  byte
GreenOld   var  byte
BlueOld    var  byte
RedUp      var  bit
GreenUp    var  bit
BlueUp     var  bit
RedFade    var  bit
GreenFade  var  Bit
BlueFade   var  bit
EepromPosition  var byte
EepromValue     var byte
EepromCounter   var byte
EepromCheck     var byte
Red=255                  'Status Leds Off (255=OFF, 0=Full Brightness)
Green=255
Blue=255
I2CExtSensor     var bit
ReadExtSensor    var bit
SensorCheck      var bit
SensorCheck=0
PowerSensor      var PORTC.5
I2cExtEnable     var PORTE.0
ExternalPowerOff var PORTD.4
OverCurrent      var PORTD.5
PullUp1          var PORTB.4
PullUp2          var PORTB.5
low PowerSensor        'Power Sensor not yet on
low ExternalPowerOff   'Switch on external 5V
high I2cExtEnable
I2CPowerReset var bit
I2CPowerReset=0
I2CPowerCounter var word


'LEDCONTROL1 var PORTB.4
'low LEDCONTROL1
'LEDCONTROL2 var PORTA.5
'low LEDCONTROL2
'LED_ST     var  PORTC.1
'high led_ST
'Leds and input on the final print
'LED_SW_2   var  PORTC.3
'high LED_SW_2
'LED_SW_1   var  PORTB.2
'high LED_SW_1
Output1    var  PORTE.1
Output2    var  PORTE.2
Output3    var  PORTD.0
Output4    var  PORTD.1
Output5    var  PORTD.2
Output6    var  PORTD.3
Input4     var  PORTA.2
Input5     var  PORTA.1
Input1     var  PORTB.2
Input2     var  PORTB.3
Input6     var  PORTA.0
Input3     var  PORTA.3
input1old var bit
input2old var bit
input1old=1
input2old=1
input3old var bit
input4old var bit
input3old=1
input4old=1
input5old var bit
input6old var bit
input5old=1
input6old=1

TempConfig var word


'i2c --------------------------------------------------------------------------
SSPADD.0=0  '?hz
SSPADD.1=0
SSPADD.2=0
SSPADD.3=1
SSPADD.4=1
SSPADD.5=0
SSPADD.6=0
SSPCON1=%00101000 'turn on MSSP and set for master mode i2c
SSPSTAT.7=1       'Slew rate off  

i2ccont var byte     'chip address
i2caddr var byte     'address within the chip to select data
i2cdata var byte[5]     'data to read or write
i2cdataTemp var byte
i2cMode var byte
i2cAck var bit
i2cInt var bit
i2cMode=0
i2cInt=0
i2creadbit var bit
i2cClock var bit
i2cClock=0
Frame var byte[3]
pcf8574 var bit
eep_addr var word
eep_addr_temp var word
Err var bit
DummyByte var byte 
Err=0


DS18B20 var bit[2]


Buffer con 180
StackSer1 var byte[buffer]
RecSer1 var bit   '=1 in receiving mode
RecSerTemp1 var byte
RecSerTemp2 var byte
PointerSer1 var byte
InterpreteSer1 var bit
RecSer1=0
PointerSer1=0
InterpreteSer1=0
ReceiveTemp var byte
i var byte
counter var byte

CheckSwitch var bit
CheckSwitch=0
BufferSize con 40
QueueTxdPointer var byte
QueueTxdByte0   var byte[BufferSize]
QueueTxdByte1   var byte[BufferSize]
QueueTxdByte2   var byte[BufferSize]
QueueTxdByte3   var byte[BufferSize]
QueueTxdByte4   var byte[BufferSize]
QueueTxdByte5   var byte[BufferSize]
QueueTxdByte6   var byte[BufferSize]
QueueTxdByte7   var byte[BufferSize]
QueueTxdSID     var word[BufferSize]
QueueTxdTime    var byte[BufferSize]
QueueTxdRetries var byte[BufferSize]
QueueTxdNrBytes var byte[BufferSize]
QueueRxdPointer var byte
QueueRxdByte0   var byte[BufferSize]
QueueRxdByte1   var byte[BufferSize]
QueueRxdByte2   var byte[BufferSize]
QueueRxdByte3   var byte[BufferSize]
QueueRxdByte4   var byte[BufferSize]
QueueRxdByte5   var byte[BufferSize]
QueueRxdByte6   var byte[BufferSize]
QueueRxdByte7   var byte[BufferSize]
QueueRxdSID0    var byte[BufferSize]
QueueRxdSID1    var byte[BufferSize]
QueueRxdTime    var byte[BufferSize]
QueueRxdNrBytes var byte[BufferSize]
QueueRxdError   var bit[BufferSize]
CRC var byte
t var byte
v var byte
s var byte
QueueTxdPointer=0
QueueRxdPointer=0
for t=0 to Buffersize-1
  QueueTxdTime[t]=255
  QueueRxdTime[t]=255
  QueueTxdRetries[t]=0
next t

RecCan var bit
RecCan=0


x var byte
y var byte
z var byte
u var byte
r var byte
a var byte
b var byte
LedCounter var byte[4]
LedCounterMax var Byte[4]
LedUp var bit
UpDownCheck var bit
LedTemp var byte
LedTempMM var byte
LedCounter[0]=0
LedCounter[1]=0
LedCounter[2]=0
LedCounter[3]=0
LedCounterMax[0]=15
LedCounterMax[1]=23
LedCounterMax[2]=29
LedCounterMax[3]=8
StatusLedCounter var word
StatusLedCounter=30
SensorToCounter var word
SensorToCounter=0
'hier sensor
SensorSentCounter var word
 
LedMode var byte
LedMode=0
LedModeOld var byte
LedModeOld=0
LedFase var byte
LedFase=0
SensorCounter var word
SensorCounter=0
CanCounter var word
CanCounter=0
ResetLedMode var word
ResetLedMode=0
CanTimer var word
CanTimer=0
mode var byte
mode="L"
OnewireOK var bit
Count_remain var byte
count_per_c var byte
TempBit var bit
DSCRC   var byte
TempCRC var byte
ICRC    var byte
DSDataByte var byte
DSCarryBit var bit
DSExtraBit var bit
TH var byte
TL var byte
Res1 var byte
Res2 var byte
CRC1 var byte
Sensor2_found var bit
Sensor3_found var bit
Sensor2_found=0
Sensor3_found=0
ROM var byte[8]


i2cwritebit var bit



;----[High Priority Interrupts]-----------------------------------------------
ASM
INT_LIST  macro    ; IntSource,             Label,  Type, ResetFlag?
        INT_Handler     TMR4_INT,         _Timer4,     PBP,  yes                 
    endm
    INT_CREATE               ; Creates the High Priority interrupt processor

;----[Low Priority Interrupts]------------------------------------------------
INT_LIST_L  macro  ; IntSource,        Label,  Type, ResetFlag?
        INT_Handler     CAN_RXB0_INT,     _RecCAN0,    PBP,  yes
        INT_Handler     CAN_RXB1_INT,     _RecCAN1,    PBP,  yes
        INT_Handler     TMR0_INT,    _Timer0,      PBP,  yes
        INT_Handler     TMR1_INT,    _Timer1,      PBP,  yes                
        INT_Handler     TMR2_INT,    _Timer2,      PBP,  yes               
        INT_Handler     SSP_INT,     _SSP,         PBP,  no         
    endm
    INT_CREATE_L             ; Creates the Low Priority interrupt processor
ENDASM


@    INT_ENABLE  TMR0_INT      ; enable Timer 0 interrupts
@    INT_ENABLE  TMR1_INT      ; enable Timer 1 interrupts
@    INT_ENABLE  TMR2_INT      ; enable Timer 2 interrupts
@    INT_ENABLE  TMR4_INT      ; enable Timer 4 interrupts
@    INT_ENABLE  CAN_RXB0_INT  ; enable CAN0 Receive interrupts
@    INT_ENABLE  CAN_RXB1_INT  ; enable CAN1 Receive interrupts
@    INT_ENABLE  SSP_INT


RCON.7=1    'enable High/Low interrupt
INTCON.7=0  'Disable all interrupts during configuration
INTCON.6=0
TMR0L=0     'reset value
TMR0H=0
TMR1L=0     'reset value
TMR1H=0
T0CON.7=0   'timer 0 disabled
T1CON.0=0   'timer 1 disabled
PIE1.1=1    'timer 2 interrupt enabled
T2CON.2=1   'start timer2
PIE1.3=1    'enable SSP interrupt
INTCON.6=1
INTCON.7=1
RCSTA1.7=0  'Disable UART1
RCSTA1.4=0  'disable UART1 receiver
PIE1.5=0    'Disable receive UART1 interrupt
PIR1.5=0    'Clear RC1IF
RCSTA1.4=0  'disable UART1 receiver
TXSTA1.5=0  'disable UART1 transmit
RCSTA2.7=1  'Enable UART2
RCSTA2.4=0  'disable UART2 receiver
TXSTA2.5=1  'enable UART2 transmit

gosub init_CAN
PIE5.4=0    'disable Transmit Buffer 2 interrupt
PIE5.3=0    'disable Transmit Buffer 1 interrupt
PIE5.2=0    'disable Transmit Buffer 0 interrupt
'IPR5.1=1    'High priority Receive Buffer 1 interrupt
'IPR5.0=1    'High priority Receive Buffer 0 interrupt
'hserout2 ["Before interrupt enable",13,10]
PIE5.0=1    'enable CAN receive buffer 0 interrupt
'hserout2 ["in between interrupt enable",13,10]
PIE5.1=1    'enable CAN receive buffer 1 interrupt

ledbit var byte
ledbit=0

INTCON.6=1
INTCON.7=1  'enable all interrupts

HDC1000_ADDRESS  con %10000000

OnBoardSensorOk var bit
SensorOk1 var bit
SensorOk2 var bit
SensorOk3 var bit
CanOK var bit
CanError var byte
CanError=0
'LedDriverOk var bit
i2cerror var word
i2cerror=0
SensorError var byte
SensorError=0
TestBit var bit
NrOfInputs var byte
NrOfInputs=255  'No Master information received yet
NrOfSensors var byte
NrOfSensors=255 'No Master information received yet
Temperature var byte
TempOld var byte
Temperature2 var byte
Temperature2=255
Temperature3 var byte
Temperature3=255
Temp2Old var byte
Temp2Old=255
Temp3Old var byte
Temp3Old=255
Temp1wire var word
TempWord var word
TempWord2 var word
Temperature=255
Humidity var byte
HumidityOld var byte
Humidity=255
Humidity3 var byte
Humidity3=255
Brightness var byte
Brightness=255
Brightness3 var byte
Brightness3=255
SwitchNr var Byte
SwitchLink var byte[8]
SensorLink var Byte
Sensorlink2 var byte
UpdateLeds var bit
UpdateLeds=1
ToggleLedsOn var bit[4]
Led var byte[6]
TempLed var byte
TempPeriodBit var bit[8]
LedPeriod var byte[8]
LedPeriod2 var Bit[8]
T4CONP var byte[8]
le var byte
bi var byte
OutputTemp var byte
LedFunction var byte[6]
LedBrightness var byte[6]
LedBrightnessMax var byte
LedBrightnessMin var Byte
LedBrightnessMax=255
LedBrightnessMin=0
WatchdogReset var bit
'Resolution con 8      'Resolution (in bits) for the led brightness
if RCON.bit3=0 then     'Watchdog has triggered the reset
  WatchdogReset=1
else                    'Normal power startup
  WatchdogReset=0
endif
CLEARWDT
'read 102,x
for i=0 to 5
'  if x=0 then
'    read 103+i,led[i]
'    read 109+i,LedFunction[i]
'    read 115+i,LedBrightness[i]
'    write 102,1
'  else
    Led[i]=0
    LedFunction[i]=0
    LedBrightness[i]=0
'  endif  
next i
gosub Led_resolution
CLEARWDT
for t=0 to 7
  read t,SwitchLink[t]
  hserout2 ["Switchlink[",dec t,"]=",dec switchlink[t],13,10]
next t
read 8,SensorLink
read 9,SensorLink2
read 200,DummyByte      'set pointer to place 200, if brown out or others happens, the current addresses won't be affected
Hserout2 ["Sensorlink=",dec SensorLink,13,10]
Hserout2 ["Sensorlink2=",dec SensorLink2,13,10]
'hier sensor
SensorSentCounter=12000+(Sensorlink*10)+(Sensorlink2*10)

CLEARWDT
lc1 var byte
lc2 var byte

ReadRom var bit
ReadConv var bit
ReadTemp var bit
CheckReset var bit
ReadRom=0
ReadConv=0
ReadTemp=0
CheckReset=0
'LedDriverOk=1
'high  PowerSensor        'Power Sensor on     
'pause 400
'gosub write_sensor        
'pause 200
'OnBoardSensorOk=1
'gosub read_sensor

'if err=1 then
'  Hserout2 ["Onboard Sensor not found",13,10]
'  OnBoardSensorOk=0
'  SensorOk1=0
'else
'  Hserout2 ["Onboard Sensor OK",13,10]
'  OnBoardSensorOk=1
'  SensorOk1=1
'endif

SensorOk3=0

COMSTATcounter var word
COMSTATcounter=0

high PowerSensor    'switch on Internal Power sensor to get external i2c to work
gosub check_ext_sensor
if SensorOk1=1 then
  gosub Reset_I2C_power
endif 

'NrResets var word
'read 102,x
'if x=0 or x=1 then
'  read 100,NrResets.byte0
'  read 101,NrResets.Byte1
'else
'  NrResets=0
'endif      
if WatchdogReset=1 then
  hserout2 ["Watchdog reset",13,10]
  QueueTxdByte0[QueueTxdPointer]=4      'SID
  QueueTxdByte1[QueueTxdPointer]=4      'Message Type (watchdog)
  QueueTxdByte2[QueueTxdPointer]=SwitchLink[0]      'Switch number
  QueueTxdByte3[QueueTxdPointer]=0      
  QueueTxdTime[QueueTxdPointer]=0       'sent message immeadiatly
  QueueTxdRetries[QueueTxdPointer]=0    '0 retries
  QueueTxdNrBytes[QueueTxdPointer]=5    'Nr of bytes to be sent
  gosub Add_Txd_queue
endif
hserout2 ["OpenMotics micro CAN F",dec version,".",dec firmware,".",dec built,13,10]

'----------------------------------------------------------------------------
' Main routine
'----------------------------------------------------------------------------

mainloop: 
  CLEARWDT 
  gosub Interprete_Serial
  gosub check_SerialErrors
  CLEARWDT
  gosub Tx_CAN
  Gosub Rx_CAN
  gosub CAN_Error
  CLEARWDT
  gosub check_sending_queue
  Gosub Switch_Control
  Gosub Check_i2c_error
  CLEARWDT
  gosub Update_led_Function  
  gosub Update_leds
  gosub Check_1wireSensor
  CLEARWDT
  gosub Check_ExtI2CSensor
  gosub Check_OverCurrent
  gosub Check_StatusLed
  CLEARWDT
  gosub Check_CanBusOk
  'hier sensor
  gosub Check_SentSensorValue
Goto mainloop

'--------------------------------------------------------------------------
' Interrupt routines
'--------------------------------------------------------------------------

Timer0:  
     T0CON.7=0  'timer 0 disabled
     INTCON.2=0 'interrupt flag cleared         
@ INT_RETURN

Timer1:    'interrupt 30 times per second
     T1CON.0=0  'timer 1 disabled
     PIR1.0=0   'interrupt flag cleared
     err=1      'error
     'delete
     if RCSTA2.7=1 then   'UART2 is enabled
       hserout2 ["Timer 1 i2c ERROR, i2cmode=",dec i2cmode,13,10]
     endif
     SensorOk1=0  
     i2cerror=i2cerror+1
     i2cmode=0  'stop        
@ INT_RETURN

Timer2:   'interrupt 244 times per second  
  T2CON.2=0
  PIR1.1=0   'clear timer2 interrupt flag 
  'code here
  CheckSwitch=1
  T2CON.2=1
@ INT_RETURN

Timer4:   'variable interrupt speed  
  'T4CON.2=0
  PIR4.7=0   'clear timer4 interrupt flag   
  T4CON=T4CONP[ledbit]
  OutputTemp=LedPeriod[ledbit]
  output1=OutputTemp.bit0
  output2=OutputTemp.bit1
  output3=OutputTemp.bit2
  output4=OutputTemp.bit3
  output5=OutputTemp.bit4
  output6=OutputTemp.bit5
  LedRed=OutputTemp.bit6
  LedGreen=OutputTemp.bit7
  LedBlue=LedPeriod2[ledbit]    
  ledbit=ledbit+1
  if ledbit>7 then ledbit=0   
  T4CON.2=1
@ INT_RETURN

RecCAN0:
   CANCON.3=1  'Receive Buffer 0
   CANCON.2=1
   CANCON.1=1   
'   CanNumber=RXB0DLC
   if RXB0D0=0 then   'ignore own messages
     QueueRxdByte0[QueueRxdPointer]=RXB0D0
     QueueRxdByte1[QueueRxdPointer]=RXB0D1
     QueueRxdByte2[QueueRxdPointer]=RXB0D2
     QueueRxdByte3[QueueRxdPointer]=RXB0D3
     QueueRxdByte4[QueueRxdPointer]=RXB0D4
     QueueRxdByte5[QueueRxdPointer]=RXB0D5
     QueueRxdByte6[QueueRxdPointer]=RXB0D6
     QueueRxdByte7[QueueRxdPointer]=RXB0D7
     QueueRxdNrBytes[QueueRxdPointer]=RXB0DLC
     QueueRxdSID1[QueueRxdPointer]=RXB0SIDH
     QueueRxdSID0[QueueRxdPointer]=RXB0SIDL
     QueueRxdTime[QueueRxdPointer]=0
     if QueueRxdPointer<BufferSize then
       QueueRxdPointer=QueueRxdPointer+1
     endif
     RecCan=1
   endif   
   RXB0CON.7=0  'buffer is clear again
   PIR5.0=0     'RXB0IF reset interrupt flag
@ INT_RETURN

RecCAN1:
   RXB1CON.7=0  'buffer is clear again
   PIR5.1=0     'RXB1IF reset interrupt flag
   'hserout2 ["CAN 1 interrupt received",13,10]   
@ INT_RETURN

SSP:
  PIE1.3=0   'disable interrupt
  i2cMode=i2cMode+1
  i2cInt=1
  'hserout2 ["Int I2C ",dec i2cmode,13,10]
  TMR0L=0
  TMR0H=0   
  PIR1.3=0   'clear interrupt flag
  PIE1.3=1   'enable interrupt  
@ INT_RETURN

'---------------------------------------------------------------------------
' Subroutines
'---------------------------------------------------------------------------

'Sent_NrOfInputs:
'  QueueTxdByte0[QueueTxdPointer]=0
'  QueueTxdByte1[QueueTxdPointer]=253       'Sent NrOfInputs
'  QueueTxdByte2[QueueTxdPointer]=NrOfInputs
'  QueueTxdByte3[QueueTxdPointer]=0
'  QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
'  QueueTxdRetries[QueueTxdPointer]=5       '5 retries
'  QueueTxdNrBytes[QueueTxdPointer]=4 
'  gosub Add_Txd_queue
'return

'Sent_NrOfSensors:
'  QueueTxdByte0[QueueTxdPointer]=0
'  QueueTxdByte1[QueueTxdPointer]=252       'Sent NrOfSensors
'  QueueTxdByte2[QueueTxdPointer]=NrOfSensors
'  QueueTxdByte3[QueueTxdPointer]=0
'  QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
'  QueueTxdRetries[QueueTxdPointer]=5       '5 retries
'  QueueTxdNrBytes[QueueTxdPointer]=4  
'  gosub Add_Txd_queue
'return

'hier sensor
Check_sentSensorValue:
    if SensorSentCounter=0 then
        SensorSentCounter=12000+(Sensorlink*10)+(Sensorlink2*10)
        'hserout2 ["Sent sensor value",13,10]
        gosub SentSensorValues
    endif
return

'hier sensor
SentSensorValues:
    if SensorLink<32 then  'Sensor information request sensor 1
        if Temperature<255 or Temperature2<255 then    
            QueueTxdByte0[QueueTxdPointer]=2
            QueueTxdByte1[QueueTxdPointer]=2
            QueueTxdByte2[QueueTxdPointer]=SensorLink
            QueueTxdByte3[QueueTxdPointer]=Temperature
            QueueTxdByte4[QueueTxdPointer]=Humidity
            QueueTxdByte5[QueueTxdPointer]=Brightness
            QueueTxdByte6[QueueTxdPointer]=Temperature2            
            QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
            QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
            QueueTxdNrBytes[QueueTxdPointer]=8  
            gosub Add_Txd_queue
            QueueTxdByte0[QueueTxdPointer]=2
            QueueTxdByte1[QueueTxdPointer]=30
            QueueTxdByte2[QueueTxdPointer]=SensorLink
            QueueTxdByte3[QueueTxdPointer]=Temperature
            QueueTxdByte4[QueueTxdPointer]=Humidity
            QueueTxdByte5[QueueTxdPointer]=Brightness
            QueueTxdByte6[QueueTxdPointer]=Temperature2            
            QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
            QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
            QueueTxdNrBytes[QueueTxdPointer]=8  
            gosub Add_Txd_queue            
            hserout2 ["Sent sensor1:",dec Sensorlink," ",dec Temperature," ",dec Temperature2,13,10]
        endif
    endif 
    if SensorLink2<32 then  'Sensor information request sensor 2
        if Temperature3<255 then        
            QueueTxdByte0[QueueTxdPointer]=2
            QueueTxdByte1[QueueTxdPointer]=2
            QueueTxdByte2[QueueTxdPointer]=SensorLink2
            QueueTxdByte3[QueueTxdPointer]=Temperature3
            QueueTxdByte4[QueueTxdPointer]=Humidity3
            QueueTxdByte5[QueueTxdPointer]=Brightness3
            QueueTxdByte6[QueueTxdPointer]=Temperature3            
            QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
            QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
            QueueTxdNrBytes[QueueTxdPointer]=8  
            gosub Add_Txd_queue
            QueueTxdByte0[QueueTxdPointer]=2
            QueueTxdByte1[QueueTxdPointer]=30
            QueueTxdByte2[QueueTxdPointer]=SensorLink2
            QueueTxdByte3[QueueTxdPointer]=Temperature3
            QueueTxdByte4[QueueTxdPointer]=Humidity3
            QueueTxdByte5[QueueTxdPointer]=Brightness3
            QueueTxdByte6[QueueTxdPointer]=Temperature3            
            QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
            QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
            QueueTxdNrBytes[QueueTxdPointer]=8  
            gosub Add_Txd_queue            
            hserout2 ["Sent sensor2:",dec Sensorlink2," ",dec Temperature3,13,10]
         endif   
    endif
return

CAN_Error:
  if COMSTAT>0 then
    COMSTAT=0
    COMSTATcounter=COMSTATcounter+1
  endif
Return

Check_CanBusOk:
  if CanOk=1 then
    CanError=0
  endif
  If CanTimer=0 then 
    CanTimer=7500
    CanOk=0         'CAN bus hasn't received messages for a while
    CanError=CanError+1
    hserout2 ["CAN bus not ok ... ",dec CanError,13,10]
    if CanError>8 then          'Request Can Control to power reset
      CanError=0
      asm
        reset
      endasm  
    endif
  endif
return

Check_StatusLed:
  if StatusLedCounter=0 then
    if ResetLedMode>29280 then 'After 2 minutes, go back to ledmode 0
      ResetLedMode=0
      LedMode=0
    endif
    if LedMode=0 then        'Indicate general status of CAN, Onboard sensor and 2 external sensors
      gosub Led_Status    
    elseif LedMode=1 then    'Indicate press of an input
      if LedFase=0 then
        Blue=255
        red=255
        Green=128               'Green half Brightness ON
        StatusLedCounter=31     'Time the led stays on
        LedFase=1
        Gosub Led_resolution   
      elseif LedFase=1 then
        Blue=255                 'All Leds off
        red=255
        Green=255                 
        StatusLedCounter=375     'Time before general status ledindication starts
        LedMode=LedModeOld       'Go back to general status indication
        LedFase=0 
        Gosub Led_resolution
      endif
      if LedFase>1 then LedFase=0    
    Elseif LedMode=2 then        'Indicates Alarm state (Red Led flashing fast)
      if LedFase=0 then      'Led Red ON
        Blue=255
        red=0
        Green=255         
        StatusLedCounter=31
        LedFase=1
        Gosub Led_resolution         
      elseif LedFase=1 then  'All Leds OFF and Pause
        Blue=255
        red=255
        Green=255         
        StatusLedCounter=31
        LedFase=0
        Gosub Led_resolution
      endif
      if LedFase>1 then LedFase=0
    Elseif LedMode=3 then        'Fade in/out color
      if BlueFade=1 then
        if Blue=255 then BlueUp=0
        if Blue=0 then BlueUp=1
        If BlueUp=1 then Blue=Blue+1
        if BlueUp=0 then Blue=Blue-1
      endif
      If RedFade=1 then               
        if Red=255 then RedUp=0
        if Red=0 then RedUp=1      
        If RedUp=1 then Red=Red+1
        if RedUp=0 then Red=Red-1
      endif
      If GreenFade=1 then               
        if Green=255 then GreenUp=0
        if Green=0 then GreenUp=1      
        If GreenUp=1 then Green=Green+1
        if GreenUp=0 then Green=Green-1
      endif                 
      StatusLedCounter=2
      Gosub Led_resolution                    
    endif
    'hserout2 ["S LED: ",dec StatusLedCounter," ",dec TempCounter," ",dec LedMode," ",dec Ledfase,13,10]
  endif
return

Led_status:
      if LedFase=0 then      'First Status Led ON
        if CanOK=1 then
          Blue=0
          red=255
        else
          Blue=255
          red=0        
        endif  
        Green=255         
        StatusLedCounter=41
        LedFase=1
        Gosub Led_resolution         
      elseif LedFase=1 then  'All Leds OFF and Pause
        Blue=255
        red=255
        Green=255         
        StatusLedCounter=54
        LedFase=2
        Gosub Led_resolution       
      elseif LedFase=2 then  'Second Status Led ON
        if I2CExtSensor=1 then        'External I2C sensor found
          blue=255
          red=255
          Green=128         
        elseif SensorOk1=1 then       'Internal I2C sensor found
          red=255
          Green=255
          Blue=0        
        else                          'Nothing found
          red=128
          Green=255       
        endif         
        StatusLedCounter=41
        LedFase=3
        Gosub Led_resolution       
      elseif LedFase=3 then  'All Leds OFF and Pause
        Blue=255
        red=255
        Green=255         
        StatusLedCounter=54
        LedFase=4
        Gosub Led_resolution          
      elseif LedFase=4 then  'Third Status Led ON
        if SensorOk2=1 then
          red=255
          Green=128
        else
          red=128
          Green=255        
        endif 
        Blue=255        
        StatusLedCounter=41
        LedFase=5
        Gosub Led_resolution       
      elseif LedFase=5 then  'All Leds OFF and Pause
        Blue=255
        red=255
        Green=255         
        StatusLedCounter=54
        LedFase=6
        Gosub Led_resolution       
      elseif LedFase=6 then  'Fourth Status Led ON
        if SensorOk3=1 then
          red=255
          Green=128
        else
          red=128
          Green=255        
        endif 
        Blue=255       
        StatusLedCounter=41
        LedFase=7
        Gosub Led_resolution         
      elseif LedFase=7 then  'All Leds OFF and Pause
        Blue=255
        red=255
        Green=255         
        StatusLedCounter=1250
        LedFase=0
        Gosub Led_resolution        
      endif 
      if LedFase>7 then LedFase=0
return

Check_OverCurrent:
  if OverCurrent=1 then
    'low LedRed
    hserout2 ["OC",13,10]
  else
    'high LedRed
  endif    
return


Onewire_read_rom:
  'Sensor2 (First external sensor)
  gosub Disable_UART2
  owout onewire,1,[$33]   'Read ROM
  gosub Enable_UART2
  gosub Disable_UART2  
  OWIN  onewire,0,[ROM[0],ROM[1],ROM[2],ROM[3],ROM[4],ROM[5],ROM[6],ROM[7]]
  gosub Enable_UART2
  'delete
  hserout2 ["ROM: ",dec ROM[0]," ",dec ROM[1]," ",dec ROM[2]," ",dec ROM[3]," ",dec ROM[4]," ",dec ROM[5]," ",dec ROM[6]," ",dec ROM[7],13,10]
  if ROM[0]=255 and ROM[1]=255 and ROM[2]=255 and ROM[3]=255 then
    Sensor2_found=0
    SensorOk2=0
  else
    Sensor2_found=1  
  endif
  if ROM[0]=255 and ROM[1]=255 and ROM[2]=255 and ROM[3]=255 then
    Sensor2_found=0
    SensorOk2=0
  elseif ROM[0]=16 or ROM[0]=40 then
    Sensor2_found=1
    If ROM[0]=16 then  'DS1820, DS18S20
      DS18B20[0]=0
      hserout2 ["DS18(S)20",13,10]
    else               'DS18B20
      DS18B20[0]=1
      hserout2 ["DS18B20",13,10]
    endif
  endif    
return

Onewire_read_rom2:
  'Sensor3 (First external sensor)  
  gosub Disable_UART2
  owout onewire2,1,[$33]   'Read ROM
  gosub Enable_UART2       'To process pending interrupts
  gosub Disable_UART2     
  OWIN  onewire2,0,[ROM[0],ROM[1],ROM[2],ROM[3],ROM[4],ROM[5],ROM[6],ROM[7]]
  gosub Enable_UART2
  'delete                                    
  hserout2 ["ROM: ",dec ROM[0]," ",dec ROM[1]," ",dec ROM[2]," ",dec ROM[3]," ",dec ROM[4]," ",dec ROM[5]," ",dec ROM[6]," ",dec ROM[7],13,10]
  if ROM[0]=255 and ROM[1]=255 and ROM[2]=255 and ROM[3]=255 then
    Sensor3_found=0
    SensorOk3=0
  elseif ROM[0]=16 or ROM[0]=40 then
    Sensor3_found=1
    If ROM[0]=16 then  'DS1820, DS18S20
      DS18B20[1]=0
      hserout2 ["DS18(S)20",13,10]
    else               'DS18B20
      DS18B20[1]=1
      hserout2 ["DS18B20",13,10]
    endif
  endif  
return

Onewire_temp_Conv:
  if Sensor2_found=1 then
    gosub Disable_UART2
    owout onewire,1,[$CC,$44]   'Start conversion
    gosub Enable_UART2
  endif 
return

Onewire_temp_Conv2:
  if Sensor3_found=1 then
    gosub Disable_UART2
    owout onewire2,1,[$CC,$44]   'Start conversion
    gosub Enable_UART2
  endif 
return

Onewire_Read_temp:
  if Sensor2_found=1 then
    DSCRC=0
    gosub Disable_UART2
    owout onewire,1,[$CC,$BE]   'Read temperature
    'OWIN  onewire,0,[Temp1wire.lowbyte,Temp1wire.highbyte,TH,TL,Res1,Res2,count_remain,count_per_c,CRC1]
    gosub Enable_UART2          'To process pending interrupts
    gosub Disable_UART2     
    OWIN  onewire,0,[Temp1wire.lowbyte,Temp1wire.highbyte,y]
    gosub Enable_UART2
    hserout2 ["1wire Sensor2: ",dec Temp1wire.lowbyte," ",dec Temp1wire.highbyte," ",dec y,13,10]  
    if y<>255 then     'Valid sensor value
      Sensorok2=1
      z=0              'First DS1820 sensor
      gosub Calc_Temp2
      gosub temp_display
      if x>(Temp2Old-4) and x<(Temp2Old+4) then  'Maximum 2 degree different between to measurements
        if x<185 and x>1 then                    'Value is ok
          Temperature2=x
          hserout2 ["Temp2=",dec ((Temperature2/2)-32),",",dec (Temperature2//2)*5,13,10]
        else                                     'value is not ok
          hserout2 ["Temp2 wrong value ",dec x,13,10]
        endif  
      else
        if Temp2old=255 then
          Temperature2=x
          hserout2 ["Temp2=",dec ((Temperature2/2)-32),",",dec (Temperature2//2)*5,13,10]
        else  
          hserout2 ["Temp2 difference too big, ignore value ",13,10]
        endif
      endif      
      Temp2Old=x
    else              'sensor not ok
      Sensorok2=0
      hserout2 ["Sensor 2 NOT OK",13,10]
    endif      
  else
    Temperature2 = 255
  endif  
return

Onewire_Read_temp2:
  if Sensor3_found=1 then
    DSCRC=0
    gosub Disable_UART2
    owout onewire2,1,[$CC,$BE]   'Read temperature
    'OWIN  onewire,0,[Temp1wire.lowbyte,Temp1wire.highbyte,TH,TL,Res1,Res2,count_remain,count_per_c,CRC1]
    gosub Enable_UART2          'To process pending interrupts
    gosub Disable_UART2       
    OWIN  onewire2,0,[Temp1wire.lowbyte,Temp1wire.highbyte,y]
    gosub Enable_UART2
    hserout2 ["1wire Sensor3: ",dec Temp1wire.lowbyte," ",dec Temp1wire.highbyte," ",dec y,13,10]  
    if y<>255 then     'Valid sensor value
      Sensorok3=1
      z=1              'Second DS1820 sensor
      gosub Calc_Temp2
      gosub temp_display     
      if x>(Temp3Old-4) and x<(Temp3Old+4) then  'Maximum 2 degree different between to measurements
        if x<185 and x>1 then     
          Temperature3=x
          hserout2 ["Temp3=",dec ((Temperature3/2)-32),",",dec (Temperature3//2)*5,13,10]
        else                                     'value is not ok
          hserout2 ["Temp3 wrong value ",dec x,13,10]      
        endif
      else
        if Temp3old=255 then
          Temperature3=x
          hserout2 ["Temp3=",dec ((Temperature3/2)-32),",",dec (Temperature3//2)*5,13,10]
        else  
          hserout2 ["Temp3 difference too big, ignore value ",13,10]
        endif  
      endif      
      Temp3Old=x
    else              'sensor not ok
      Sensorok3=0
      hserout2 ["Sensor 3 NOT OK",13,10]
    endif   
  else
    Temperature3 = 255
  endif  
return

Temp_display:
    hserout2 ["System value OM: ",dec x," -> "]
    if x>63 then                              'temperature positive
      z=(x/2)-32
      y="+"
    else                                      'temperature negative
      x=64-x                                  'Bug: Value x is changed here which is wrong, going to 
      z=x/2
      y="-"   
    endif    
    if x=255 then                             'sensor not connected
      hserout2 ["--.-",13,10]
      'SensorOk2=0  
    else
      hserout2 [y,dec2 z,".",dec (x//2)*5,13,10]
      'SensorOk2=1
    endif
return

Calc_Temp2:
  if DS18B20[z]=1 then   'It's a DS18B20 so convert the value of the registers
    Temp1Wire.byte0=Temp1Wire.byte0>>3
    x=Temp1Wire.byte1<<5
    x=x&%11100000
    Temp1Wire.byte0=Temp1Wire.byte0|x
    x=Temp1Wire.byte1
    if x.bit7=1 then
      Temp1Wire.byte1=255
    else
      Temp1Wire.byte1=0
    endif
  endif
  if Temp1Wire.byte1=0 then  
    if Temp1wire.byte0<169 then
      x = Temp1wire.byte0 + 64
    else
      x = 255
    endif  
  else
    if Temp1wire.byte0>191 then
      x = Temp1wire.byte0 - 192
    else
      x = 255     
    endif  
  endif
return

Check_CRC:
  DSDatabyte = Temp1wire.lowbyte
  gosub Check_1wireCRC  
  DSDatabyte = Temp1wire.highbyte
  gosub Check_1wireCRC  
  DSDatabyte = TH
  gosub Check_1wireCRC 
  DSDatabyte = TL
  gosub Check_1wireCRC  
  DSDatabyte = Res1  
  gosub Check_1wireCRC  
  DSDatabyte = Res2
  gosub Check_1wireCRC            
  DSDatabyte = Count_remain
  gosub Check_1wireCRC     
  DSDatabyte = Count_per_c
  gosub Check_1wireCRC  
  DSDatabyte = CRC1
  gosub Check_1wireCRC        
return

Check_1wireCRC:
  for ICRC=0 to 7
    TempCRC = DSCRC ^ DSDataByte
    DSCarryBit = TempCRC.0
    if TempCRC.0=0 then CRCPlace
    DSCRC = DSCRC ^ $18
    CRCPlace:  
    DSExtraBit=DSCarryBit
    DSCarryBit=DSCRC.0
    DSCRC.7=DSExtraBit
    DSDataByte=DSDataByte>>1
  next ICRC
return

Disable_UART2:
  'RCSTA2.7=0  'disable UART2
  'RCSTA2.4=0  'disable UART2 receiver
  'TXSTA2.5=0  'disable UART2 transmit
  INTCON.6=0
  INTCON.7=0  'disable all interrupts
return

Enable_UART2:
  'RCSTA2.4=0  'disable UART2 receiver
  'TXSTA2.5=1  'enable UART2 transmit
  'RCSTA2.7=1  'Enable UART2
  INTCON.6=1
  INTCON.7=1  'enable all interrupts  
return

Led_resolution:
  for bi=0 to 7      'Prepare variables to keep interrupt very short, 8 periods (only 5 are used for the moment)
    for le=0 to 5    '6 leds or outputs
      TempLed=Led[le]
      TempLed=TempLed>>bi    
      TempPeriodBit[le]=TempLed.bit0
    next le
    Templed=red>>bi
    TempPeriodBit[6]=TempLed.bit0
    Templed=Green>>bi
    TempPeriodBit[7]=TempLed.bit0    
    TempLed.bit0=TempPeriodBit[0]
    TempLed.bit1=TempPeriodBit[1]
    TempLed.bit2=TempPeriodBit[2]
    TempLed.bit3=TempPeriodBit[3]
    TempLed.bit4=TempPeriodBit[4]
    TempLed.bit5=TempPeriodBit[5]
    TempLed.bit6=TempPeriodBit[6]
    TempLed.bit7=TempPeriodBit[7]    
    LedPeriod[bi]=TempLed
    TempLed=Blue>>bi
    LedPeriod2[bi]=TempLed.bit0 
  next bi
  T4CONP[0]=%00000100   '1
  T4CONP[1]=%00001100   '2 'fastest period
  T4CONP[2]=%00011100   '4
  T4CONP[3]=%00111100   '8
  T4CONP[4]=%01111100   '16
  T4CONP[5]=%00111101   '32
  T4CONP[6]=%01111101   '64
  T4CONP[7]=%00111111   '128
  'T4CONP[7]=%01111111   '256 'slowest period         
return

Check_Led_MinMax:
  if LedTempMM=0 then              'Led is off
    Led[i]=LedBrightnessMin
  else                             'Led is on
    if LedTempMM>LedBrightnessMax then
      Led[i]=LedBrightnessMax
    else          
      Led[i]=LedTempMM
    endif
  endif
  'led[i]=led[i]>>(8-Resolution)   'correct resolution
  gosub Led_resolution
return

Update_Led_Function:
  for a=0 to 3                                  'LedFunction[i]=0 -> Normal ON/OFF
    If LedCounter[a]>LedCounterMax[a] then      'LedFunction[i]=1 -> Blink Fast
      LedCounter[a]=0                           'LedFunction[i]=2 -> Blink Medium
      if ToggleLedsOn[a]=1 then                 'LedFunction[i]=3 -> Blink Slow
        ToggleLedsOn[a]=0                       
      else                                      'LedFunction[i]=4 -> Dim up .. down .. up ..
        ToggleLedsOn[a]=1
      endif
      UpDownCheck=0    
      for i=0 to 5
        if LedFunction[i]=1 or LedFunction[i]=2 or LedFunction[i]=3 then 'Led Blinking
          if LedFunction[i]=a+1 then
            if ToggleLedsOn[a]=1 then
              LedTempMM=LedBrightness[i]
              gosub Check_Led_MinMax
            else
              led[i]=LedBrightnessMin
              'led[i]=led[i]>>(8-Resolution)   'correct resolution
              gosub Led_resolution
            endif
            UpdateLeds=1
          endif   
        elseif LedFunction[i]=4 then                                     'Dim up ... down ... up
          if LedUp=1 then
            if UpDownCheck=0 then 
              LedTemp=LedTemp+2
              UpDownCheck=1
            endif 
            if LedTemp>LedBrightness[i] then
              LedTemp=LedBrightness[i]
              'Toggle LedUp
              if LedUp=1 then
                LedUp=0
              else
                LedUp=1
              endif    
            endif  
          else
            if UpDownCheck=0 then 
              LedTemp=LedTemp-2
              UpDownCheck=1
            endif 
            If LedTemp>250 then 
              LedTemp=0
              'Toggle LedUp
              if LedUp=1 then
                LedUp=0
              else
                LedUp=1
              endif                
            endif  
          endif
          LedTempMM=LedTemp
          gosub Check_Led_MinMax
          'Led[i]=LedTemp
          UpdateLeds=1
        endif 
      next i
    endif
  next a  
return

Update_leds:
  if UpdateLeds=1 then
    UpdateLeds=0
    for i=0 to 5
      if LedFunction[i]=0 then                  'LedFunction[i]=0 -> Normal ON/OFF
        LedTempMM=LedBrightness[i]
        gosub Check_Led_MinMax
      endif     
    '  if Led[i]>0 then    'Led ON
    '    hserout2 ["Output ",dec i," ",dec Led[i]," ON",13,10]
    '    'gosub Led_on
    '  else                'Led OFF
    '    hserout2 ["Led ",dec i," OFF",13,10]
    '    'gosub Led_off
    '  endif
    next i
    gosub Check_status_off
'    for i=0 to 5
'      if LedFunction[i]=0 then                  'LedFunction[i]=0 -> Normal ON/OFF
'        LedTempMM=LedBrightness[i]
'        gosub Check_Led_MinMax
'      endif  
'    next i
'    'LedConfig[0]=%0011101010100000   'Configuration byte, should never be changed (8 bits used)
'    'LedConfig[4]=%0011101010100000   'Configuration byte, should never be changed (8 bits used)        
'    for i=1 to 3
'      Tempword.byte0=0
'      Tempword.byte1=Led[i+2]
'      'LedConfig[i]=Tempword
'    next i
'    for i=5 to 7
'      Tempword.byte0=0
'      Tempword.byte1=Led[i-5]
'      'LedConfig[i]=Tempword
'    next i       
'    'gosub SET_LEDS
  endif  
return

Led_On:
  if i=0 then
    high Output1
  endif
  if i=1 then
    high Output2
  endif
  if i=2 then
    high Output3
  endif
  if i=3 then
    high Output4
  endif
  if i=4 then
    high Output5
  endif
  if i=5 then
    high Output6
  endif          
return

Led_Off:
  if i=0 then
    low Output1
  endif
  if i=1 then
    low Output2
  endif
  if i=2 then
    low Output3
  endif
  if i=3 then
    low Output4
  endif
  if i=4 then
    low Output5
  endif
  if i=5 then
    low Output6
  endif 
return

Check_receive_queue:
  if QueueRxdPointer>0 then
    for t=0 to QueueRxdPointer-1
      'hserout2 ["Handle Receiving queue message ",dec t,"/",dec QueueRxdPointer," ",dec QueueRxdByte0[t]," ",dec QueueRxdByte1[t]," ",dec QueueRxdByte2[t]," ",dec QueueRxdByte3[t]," ",dec QueueRxdByte4[t]," ",dec QueueRxdByte5[t]," ",dec QueueRxdByte6[t]," ",dec QueueRxdByte7[t]," ",dec QueueRxdNrBytes[t],13,10]
      QueueRxdTime[t]=255    'Message has been handled
      gosub Check_message     
    next t
    gosub Clean_Receiving_Queue
    'x=QueueRxdPointer
    'for t=x-1 to 0 step -1
    '  if QueueRxdTime[t]=255 and QueueRxdError[t]=0 then  'Confirmation received that message is well received so message can be deleted from queue
    '    'hserout2 ["Clean Receiving Queue=",dec t," ",13,10]
    '    QueueRxdPointer=QueueRxdPointer-1
    '  endif
    'next t      
  endif
Return

Calculate_Rxd_CRC:
  if QueueRxdNrBytes[t]=2 then
    CRC=QueueRxdByte0[t]
    if QueueRxdByte1[t]=CRC then
      QueueRxdError[t]=0    'No Error, message OK
    else
      QueueRxdError[t]=1    'Error, message NOK
      'hserout2 ["CRC ERROR2 ",dec t,13,10]
    endif
  elseif QueueRxdNrBytes[t]=3 then
    CRC=QueueRxdByte0[t]+QueueRxdByte1[t]
    if QueueRxdByte2[t]=CRC then
      QueueRxdError[t]=0    'No Error, message OK
    else
      QueueRxdError[t]=1    'Error, message NOK
      'hserout2 ["CRC ERROR3 ",dec t,13,10]      
    endif  
  elseif QueueRxdNrBytes[t]=4 then
    CRC=QueueRxdByte0[t]+QueueRxdByte1[t]+QueueRxdByte2[t]
    if QueueRxdByte3[t]=CRC then
      QueueRxdError[t]=0    'No Error, message OK
    else
      QueueRxdError[t]=1    'Error, message NOK
      'hserout2 ["CRC ERROR4 ",dec t,13,10]      
    endif   
  elseif QueueRxdNrBytes[t]=5 then
    CRC=QueueRxdByte0[t]+QueueRxdByte1[t]+QueueRxdByte2[t]+QueueRxdByte3[t]
    if QueueRxdByte4[t]=CRC then
      QueueRxdError[t]=0    'No Error, message OK
    else
      QueueRxdError[t]=1    'Error, message NOK
      'hserout2 ["CRC ERROR5 ",dec t,13,10]      
    endif    
  elseif QueueRxdNrBytes[t]=6 then
    CRC=QueueRxdByte0[t]+QueueRxdByte1[t]+QueueRxdByte2[t]+QueueRxdByte3[t]+QueueRxdByte4[t]
    if QueueRxdByte5[t]=CRC then
      QueueRxdError[t]=0    'No Error, message OK
    else
      QueueRxdError[t]=1    'Error, message NOK
      'hserout2 ["CRC ERROR6 ",dec t,13,10]      
    endif    
  elseif QueueRxdNrBytes[t]=7 then
    CRC=QueueRxdByte0[t]+QueueRxdByte1[t]+QueueRxdByte2[t]+QueueRxdByte3[t]+QueueRxdByte4[t]+QueueRxdByte5[t]
    if QueueRxdByte6[t]=CRC then
      QueueRxdError[t]=0    'No Error, message OK
    else
      QueueRxdError[t]=1    'Error, message NOK
      'hserout2 ["CRC ERROR7 ",dec t,13,10]      
    endif   
  elseif QueueRxdNrBytes[t]=8 then
    CRC=QueueRxdByte0[t]+QueueRxdByte1[t]+QueueRxdByte2[t]+QueueRxdByte3[t]+QueueRxdByte4[t]+QueueRxdByte5[t]+QueueRxdByte6[t]
    if QueueRxdByte7[t]=CRC then
      QueueRxdError[t]=0    'No Error, message OK
    else
      QueueRxdError[t]=1    'Error, message NOK
      'hserout2 ["CRC ERROR8 ",dec t,13,10]      
    endif   
  endif
return

Check_status_off:
  if LedMode=3 then
    if LedBrightness[0]=LedBrightnessMin and LedBrightness[1]=LedBrightnessMin and LedBrightness[2]=LedBrightnessMin and LedBrightness[3]=LedBrightnessMin and LedBrightness[4]=LedBrightnessMin and LedBrightness[5]=LedBrightnessMin then
      LedMode=0
      LedFase=0
      Blue=255
      Red=255
      Green=255      
      StatusLedCounter=125    'Led function almost immeadiatly         
    endif
  endif  
return

Check_message:     't is already used
  gosub Calculate_Rxd_CRC
  if QueueRxdError[t]=0  then  'CRC check ok, message has no error
    if QueueRxdByte1[t]=0 then
      hserout2 ["CAN bus wrongly connected, please recheck the L and H connection",13,10]
      CanOK=0
    elseif QueueRxdByte1[t]=1 then
      'hserout2 ["Button confirmation info received ",dec QueueRxdByte2[t],13,10]
      gosub Check_Queue_message   'Check if this is the confirmation i'm waiting on so the sent item in the queue can be deleted
      'hier sensor
    elseif QueueRxdByte1[t]=2 then
      read 8,SensorLink
      if QueueRxdByte2[t]=SensorLink then  'Sensor information request sensor 1    
        QueueTxdByte0[QueueTxdPointer]=2
        QueueTxdByte1[QueueTxdPointer]=2
        QueueTxdByte2[QueueTxdPointer]=SensorLink
        QueueTxdByte3[QueueTxdPointer]=Temperature
        QueueTxdByte4[QueueTxdPointer]=Humidity
        QueueTxdByte5[QueueTxdPointer]=Brightness
        QueueTxdByte6[QueueTxdPointer]=Temperature2            
        QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
        QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
        QueueTxdNrBytes[QueueTxdPointer]=8  
        gosub Add_Txd_queue
        CanOk=1
        CanTimer=7500
        'hier sensor
        SensorSentCounter=12000+(SensorLink*10)+(SensorLink2*10)
        hserout2 ["Temp request ",dec QueueRxdByte2[t]," = ",dec SensorLink," Temp= ",dec Temperature," ",dec Temperature2,13,10]
      endif
      read 9,SensorLink2
      read 200,DummyByte      'set pointer to place 200, if brown out or others happens, the current addresses won't be affected 
      if QueueRxdByte2[t]=SensorLink2 then  'Sensor information request sensor 2    
        QueueTxdByte0[QueueTxdPointer]=2
        QueueTxdByte1[QueueTxdPointer]=2
        QueueTxdByte2[QueueTxdPointer]=SensorLink2
        QueueTxdByte3[QueueTxdPointer]=Temperature3
        QueueTxdByte4[QueueTxdPointer]=Humidity3
        QueueTxdByte5[QueueTxdPointer]=Brightness3
        QueueTxdByte6[QueueTxdPointer]=Temperature3            
        QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
        QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
        QueueTxdNrBytes[QueueTxdPointer]=8  
        gosub Add_Txd_queue
        CanOk=1
        CanTimer=7500
        'hier sensor
        SensorSentCounter=12000+(SensorLink*10)+(SensorLink2*10)
        hserout2 ["Temp request ",dec QueueRxdByte2[t]," = ",dec Sensorlink2," Temp= ",dec Temperature3,13,10]
      endif       
    elseif QueueRxdByte1[t]=3 then
      hserout2 ["LED SET ",dec QueueRxdByte2[t]," ",dec QueueRxdByte3[t]," ",dec QueueRxdByte4[t],13,10]
      for a=0 to 5
        'hserout2 [" Link ",dec a," ",dec SwitchLink[a],13,10]
        if SwitchLink[a]=QueueRxdByte2[t] then
          'hserout2 [" Link found ",dec a," ",dec SwitchLink[a],13,10]      
          LedBrightness[a]=QueueRxdByte3[t]
          LedFunction[a]=QueueRxdByte4[t]
          UpdateLeds=1
        endif
      next a
      CanOk=1
      CanTimer=7500
    elseif QueueRxdByte1[t]=4 then
      if QueueRxdByte2[t]=SensorLink then  'Sensor indicate request first sensor
        hserout2 ["TEMP1 INDICATE ",dec sensorlink,13,10] 
        for a=0 to 5
          if QueueRxdByte3[t]=1 then
            LedBrightness[a]=255
          else
            LedBrightness[a]=0
          endif    
          LedFunction[a]=4
        next a
        UpdateLeds=1
        LedModeOld=LedMode    'After this led function, return to the previous led function
        ResetLedMode=0        'Reset counter and after 2 minutes go back to LedMode=0
        LedMode=3             'Fade in-out
        LedFase=0
        BlueFade=1            'Fade Blue
        GreenFade=0           'Don't Fade Green
        RedFade=0             'Don't Fade Red
        Blue=255
        Red=255
        Green=255
        StatusLedCounter=0    'Led function immeadiatly
        CanOk=1
        CanTimer=7500
      endif
      if QueueRxdByte2[t]=SensorLink2 then  'Sensor indicate request second sensor
        hserout2 ["TEMP2 INDICATE ",dec sensorlink2,13,10] 
        for a=0 to 5
          if QueueRxdByte3[t]=1 then
            LedBrightness[a]=255
          else
            LedBrightness[a]=0
          endif    
          LedFunction[a]=4
        next a
        UpdateLeds=1
        LedModeOld=LedMode    'After this led function, return to the previous led function
        ResetLedMode=0        'Reset counter and after 2 minutes go back to LedMode=0
        LedMode=3             'Fade in-out
        LedFase=0
        BlueFade=1            'Fade Blue
        GreenFade=0           'Don't Fade Green
        RedFade=1             'Fade Red
        Blue=255
        Red=255
        Green=255
        StatusLedCounter=0    'Led function immeadiatly
        CanOk=1
        CanTimer=7500
      endif     
    elseif QueueRxdByte1[t]=5 then                                  'Input indicate (CAN Control will also sent LED SET INSTRUCTION)
      hserout2 ["LED INDICATE ",dec QueueRxdByte2[t]," ",dec QueueRxdByte3[t]," ",dec QueueRxdByte4[t],13,10]
      for a=0 to 5
        if SwitchLink[a]=QueueRxdByte2[t] then
          UpdateLeds=1
          LedModeOld=LedMode    'After this led function, return to the previous led function
          ResetLedMode=0        'Reset counter and after 2 minutes go back to LedMode=0
          LedMode=3             'Fade in-out
          LedFase=0
          BlueFade=0            'Don't Fade Blue
          GreenFade=1           'Fade Green
          RedFade=0             'Don't Fade Red
          Blue=255
          Red=255
          Green=255
          StatusLedCounter=0    'Led function immeadiatly
        endif
      next a
      CanOk=1
      CanTimer=7500
    elseif QueueRxdByte1[t]=6 then               'Ping instruction for an input received
      hserout2 ["PING ",dec QueueRxdByte2[t]," ",dec QueueRxdByte3[t]," ",dec QueueRxdByte4[t],13,10]
      for a=0 to 5
        'hserout2 [" Link ",dec a," ",dec SwitchLink[a],13,10]
        if SwitchLink[a]=QueueRxdByte2[t] then
          QueueTxdByte0[QueueTxdPointer]=6
          QueueTxdByte1[QueueTxdPointer]=6
          QueueTxdByte2[QueueTxdPointer]=SwitchLink[a]
          QueueTxdByte3[QueueTxdPointer]=0
          QueueTxdByte4[QueueTxdPointer]=0
          QueueTxdByte5[QueueTxdPointer]=0
          QueueTxdByte6[QueueTxdPointer]=0            
          QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
          QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
          QueueTxdNrBytes[QueueTxdPointer]=6  
          gosub Add_Txd_queue          
        endif
      next a
      CanOk=1
      CanTimer=7500       
    elseif QueueRxdByte1[t]=248 then           'Request to sent back ping (only used for testing)
      QueueTxdByte0[QueueTxdPointer]=248
      QueueTxdByte1[QueueTxdPointer]=248
      QueueTxdByte2[QueueTxdPointer]="O"
      QueueTxdByte3[QueueTxdPointer]="K"
      QueueTxdByte4[QueueTxdPointer]=0
      QueueTxdByte5[QueueTxdPointer]=0
      QueueTxdByte6[QueueTxdPointer]=0            
      QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
      QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
      QueueTxdNrBytes[QueueTxdPointer]=6  
      gosub Add_Txd_queue
      CanOk=1
      CanTimer=7500                      
    elseif QueueRxdByte1[t]=249 then  'Reset Temp/Hum sensor as broadcast messsage
      'hserout2 ["Reset TYemp/Hum sensor",13,10]    
      i2cerror=5     'Trigger i2c reset routine      
    elseif QueueRxdByte1[t]=250 then  'Set Min/Max of all Leds as broadcast messsage
      'hserout2 ["Ledbrightness received",13,10]    
      LedBrightnessMin=QueueRxdByte3[t]
      LedBrightnessMax=QueueRxdByte4[t]
      UpdateLeds=1      
    elseif QueueRxdByte1[t]=251 then  'All leds off as broadcast messsage
      'hserout2 ["All leds off",13,10]    
      for a=0 to 5
        LedBrightness[a]=0   
        LedFunction[a]=0
      next a
      UpdateLeds=1
      LedMode=0
      LedFase=0
      Blue=255
      Red=255
      Green=255      
      StatusLedCounter=125    'Led function almost immeadiatly
      CanOk=1
      CanTimer=60000                          
    elseif QueueRxdByte1[t]=252 then  'NrOfSensor received as broadcast messsage
      hserout2 ["NR OF SENSORS RECEIVED ",dec QueueRxdByte2[t],13,10]    
      if QueueRxdByte2[t]<32 then NrOfSensors=QueueRxdByte2[t]
      'if NrOfSensors=0 and (SensorLink<>255 or SensorLink2<>255) then
      '  SensorLink=255
      '  write 8,255
      '  SensorLink2=255
      '  write 9,255        
      'endif
      gosub Check_Queue_message   'Check if this is the confirmation i'm waiting on so the sent item in the queue can be deleted
      CanOk=1
      CanTimer=7500             
    elseif QueueRxdByte1[t]=253 then  'NrOfInputs received as broadcast messsage
      hserout2 ["NR OF INPUTS RECEIVED ",dec QueueRxdByte2[t],13,10]    
      if QueueRxdByte2[t]<240 then NrOfInputs=QueueRxdByte2[t]
      'if NrOfInputs=0 then
      '  for r=0 to 7
      '    if SwitchLink[r]<>255 then
      '      SwitchLink[r]=255
      '      write r,255
      '    endif
      '  next r
      'endif
      CanOk=1
      CanTimer=7500      
      gosub Check_Queue_message   'Check if this is the confirmation i'm waiting on so the sent item in the queue can be deleted        
    elseif QueueRxdByte1[t]=254 then  'Alive message: CAN control will sent message every few seconds to indicate it is alive   
      'hserout2 ["Keep Alive RECEIVED",13,10]
      CanOk=1
      CanTimer=7500
    elseif QueueRxdByte1[t]==190 then   'Delete inputs or sensors
        if QueueRxdByte3[t]==69 and QueueRxdByte4[t]==1 and QueueRxdByte5[t]==17 then   'delete code is correct
            if QueueRxdByte2[t]=="I" then   'Delete Inputs
                for r=0 to 7
                    if SwitchLink[r]<>255 then
                        hserout2 ["Delete input ",dec r," ",dec SwitchLink[r],13,10]
                        SwitchLink[r]=255
                        EepromPosition=r
                        EepromValue=255
                        gosub Write_eeprom_and_verify 
                        'write r,255
                    endif
                next r
                NrOfInputs=0        
            endif
            if QueueRxdByte2[t]=="S" then   'Delete Sensors
                if SensorLink<>255 then
                    hserout2 ["Delete sensor 0 ",dec SensorLink,13,10]
                    SensorLink=255
                    EepromPosition=8
                    EepromValue=255
                    gosub Write_eeprom_and_verify                     
                    'write 8,255
                endif
                if SensorLink2<>255 then
                    hserout2 ["Delete sensor 1 ",dec SensorLink2,13,10]    
                    SensorLink2=255
                    EepromPosition=9
                    EepromValue=255
                    gosub Write_eeprom_and_verify                     
                    'write 9,255
                endif            
            endif            
        endif          
    endif
  endif    
return

Calculate_Txd_CRC:
  if QueueTxdNrBytes[QueueTxdPointer]=2 then
    QueueTxdByte1[QueueTxdPointer]=QueueTxdByte0[QueueTxdPointer]
  elseif QueueTxdNrBytes[QueueTxdPointer]=3 then
    QueueTxdByte2[QueueTxdPointer]=QueueTxdByte0[QueueTxdPointer]+QueueTxdByte1[QueueTxdPointer]  
  elseif QueueTxdNrBytes[QueueTxdPointer]=4 then
    QueueTxdByte3[QueueTxdPointer]=QueueTxdByte0[QueueTxdPointer]+QueueTxdByte1[QueueTxdPointer]+QueueTxdByte2[QueueTxdPointer]   
  elseif QueueTxdNrBytes[QueueTxdPointer]=5 then
    QueueTxdByte4[QueueTxdPointer]=QueueTxdByte0[QueueTxdPointer]+QueueTxdByte1[QueueTxdPointer]+QueueTxdByte2[QueueTxdPointer]+QueueTxdByte3[QueueTxdPointer]   
  elseif QueueTxdNrBytes[QueueTxdPointer]=6 then
    QueueTxdByte5[QueueTxdPointer]=QueueTxdByte0[QueueTxdPointer]+QueueTxdByte1[QueueTxdPointer]+QueueTxdByte2[QueueTxdPointer]+QueueTxdByte3[QueueTxdPointer]+QueueTxdByte4[QueueTxdPointer]   
  elseif QueueTxdNrBytes[QueueTxdPointer]=7 then
    QueueTxdByte6[QueueTxdPointer]=QueueTxdByte0[QueueTxdPointer]+QueueTxdByte1[QueueTxdPointer]+QueueTxdByte2[QueueTxdPointer]+QueueTxdByte3[QueueTxdPointer]+QueueTxdByte4[QueueTxdPointer]+QueueTxdByte5[QueueTxdPointer]  
  elseif QueueTxdNrBytes[QueueTxdPointer]=8 then
    QueueTxdByte7[QueueTxdPointer]=QueueTxdByte0[QueueTxdPointer]+QueueTxdByte1[QueueTxdPointer]+QueueTxdByte2[QueueTxdPointer]+QueueTxdByte3[QueueTxdPointer]+QueueTxdByte4[QueueTxdPointer]+QueueTxdByte5[QueueTxdPointer]+QueueTxdByte6[QueueTxdPointer]  
  endif
  'delete
  'hserout2 [dec QueueTxdNrBytes[QueueTxdPointer]," : ",dec QueueTxdByte7[QueueTxdPointer]," ",dec QueueTxdByte6[QueueTxdPointer]," ",dec QueueTxdByte5[QueueTxdPointer]," ",dec QueueTxdByte4[QueueTxdPointer]," ",dec QueueTxdByte3[QueueTxdPointer]," ",dec QueueTxdByte2[QueueTxdPointer]," ",dec QueueTxdByte1[QueueTxdPointer]," ",dec QueueTxdByte0[QueueTxdPointer]," ",13,10] 
return

Check_queue_message:
  if QueueTxdPointer>0 then
    for u=0 to QueueTxdPointer-1
      if QueueRxdByte1[t]=QueueTxdByte1[u] and QueueRxdByte2[t]=QueueTxdByte2[u] then  'Correct confirmation received
        'hserout2 ["correct message received, ",dec QueueRxdByte1[t]," ",dec QueueRxdByte2[t],13,10]
        QueueTxdTime[u]=255        'message can be indicated as being sent and confirmation that it has been well received by the CAN master
       endif
    next u
    gosub Clean_sending_queue
  endif  
return

Add_Txd_queue:
  gosub Calculate_Txd_CRC
  if QueueTxdPointer<Buffersize then
    QueueTxdPointer=QueueTxdPointer+1
  endif
return

check_sending_queue:
  if QueueTxdPointer>0 then
    if TXB0CON.3=0 then
      for t=0 to QueueTxdPointer-1
        if QueueTxdTime[t]=0 then    'Execute queue action
          'hserout2 ["Execute Sent Queue, QueueTxdPointer=",dec QueueTxdPointer," ",dec t," ",dec QueueTxdByte0[t]," ",dec QueueTxdByte1[t]," ",dec QueueTxdByte2[t]," ",dec QueueTxdByte3[t],13,10]
          QueueTxdTime[t]=10
          COMSTAT.0=0   'Clear errors
          COMSTAT.1=0
          COMSTAT.2=0
          'toggle led_2
          counter=counter+1
          TXB0SIDH=%00000000
          TXB0SIDL=%11000000 'standard mode (SID 11 bits)
          TXB0DLC=QueueTxdNrBytes[t]          'sent x bytes
          TXB0D0=QueueTxdByte0[t]
          TXB0D1=QueueTxdByte1[t]
          TXB0D2=QueueTxdByte2[t]
          TXB0D3=QueueTxdByte3[t]
          TXB0D4=QueueTxdByte4[t]
          TXB0D5=QueueTxdByte5[t]
          TXB0D6=QueueTxdByte6[t]
          TXB0D7=QueueTxdByte7[t]          
          TXB0CON.3=1    'Request sending message
          if QueueTxdRetries[t]=0 then 
            QueueTxdTime[t]=255   'message can be removed from the queue
          else
            QueueTxdTime[t]=10    'Wait 10 ticks for response to come in, otherwise retry again
          endif  
          t=QueueTxdPointer-1  'exit        
        endif
      next t
      gosub clean_sending_queue
    endif
  endif     
return

Clean_receiving_Queue:
  if QueueRxdPointer>0 then
    TestBit=0
    for t=0 to QueueRxdPointer-1
      if QueueRxdTime[t]<>255 then  'Messages that must remain in the sending queue?
        TestBit=1
      endif
    next t
    If Testbit=0 then
      QueueRxdPointer=0
      'hserout2 ["Sending queue is empty again",13,10]
    endif
  endif 
return

Clean_sending_queue:
  if QueueTxdPointer>0 then
    TestBit=0
    for v=0 to QueueTxdPointer-1
      if QueueTxdTime[v]<>255 then  'Messages that must remain in the sending queue?
        TestBit=1
      endif
    next v
    If Testbit=0 then
      QueueTxdPointer=0
      'hserout2 ["Sending queue is empty again",13,10]
    endif
  endif  
return

Request_NrOfSensors:
      QueueTxdByte0[QueueTxdPointer]=100 'Request Nr of Sensors from CAN controller
      QueueTxdByte1[QueueTxdPointer]=252
      QueueTxdByte2[QueueTxdPointer]=0
      QueueTxdByte3[QueueTxdPointer]=0     
      QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
      QueueTxdRetries[QueueTxdPointer]=3       '3 retries
      QueueTxdNrBytes[QueueTxdPointer]=4  
      gosub Add_Txd_queue
return

Sent_NrOfSensors:   
      'QueueTxdByte0[QueueTxdPointer]=252 'Sent new Nr of Sensors to CAN controller
      'QueueTxdByte1[QueueTxdPointer]=252
      'QueueTxdByte2[QueueTxdPointer]=NrOfSensors
      'QueueTxdByte3[QueueTxdPointer]=0     
      'QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
      'QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
      'QueueTxdNrBytes[QueueTxdPointer]=4  
      'gosub Add_Txd_queue
      'QueueTxdByte0[QueueTxdPointer]=0   'Sent new Nr of Sensors to all clients
      'QueueTxdByte1[QueueTxdPointer]=252
      'QueueTxdByte2[QueueTxdPointer]=NrOfSensors
      'QueueTxdByte3[QueueTxdPointer]=0     
      'QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
      'QueueTxdRetries[QueueTxdPointer]=0       'No retries so no response is expected
      'QueueTxdNrBytes[QueueTxdPointer]=4  
      'gosub Add_Txd_queue
return

Check_SensorLink:
  read 8,SensorLink
  read 9,SensorLink2
  read 200,DummyByte      'set pointer to place 200, if brown out or others happens, the current addresses won't be affected
  hserout2 ["SensorLink ",dec SensorLink," ",dec Sensorlink2," SensorOk ",dec SensorOk1," ",dec SensorOk2," ",dec SensorOk3," NrofSensors ",dec NrOfSensors,13,10]
  if SensorLink>31 and (SensorOk1=1 or SensorOk2=1) then   'Sensor not yet initialized
    if NrOfSensors<32 then
      SensorLink=NrOfSensors
      EepromPosition=8
      EepromValue=NrOfSensors
      gosub Write_eeprom_and_verify
      'write 8,NrOfSensors
      NrOfSensors=NrOfSensors+1  
      'gosub Sent_NrOfSensors
      gosub SentSensorValues
      hserout2 ["First sensor added ",dec NrOfSensors,13,10]
    else
      'Request Nr of Sensors
      gosub Request_NrOfSensors
      'hserout2 ["Request Nr of Sensors ",13,10]              
    endif    
  endif  
  if SensorLink2>31 and SensorOk3=1 then   'Sensor not yet initialized
    if NrOfSensors<32 then
      SensorLink2=NrOfSensors
      EepromPosition=9
      EepromValue=NrOfSensors
      gosub Write_eeprom_and_verify      
      'write 9,NrOfSensors 
      NrOfSensors=NrOfSensors+1    
      'gosub Sent_NrOfSensors
      gosub SentSensorValues
      hserout2 ["Second sensor added ",dec NrOfSensors,13,10]
    'else
      'Request Nr of Sensors
      'gosub Request_NrOfSensors
      'hserout2 ["Request Nr of Sensors ",13,10]              
    endif    
  endif  
return

Write_eeprom_and_verify:
    write EepromPosition,EepromValue
    for EepromCounter=0 to 5
        read EepromPosition,EepromCheck
        if EepromValue==EepromCheck then    'write has succeeded
            EepromCounter=5                 'exit
            hserout2 ["Eeprom write OK pos ",dec EepromPosition," Value ",dec EepromValue,13,10]
        else                                'write has failed, rewrite
            write EepromPosition,EepromValue
            hserout2 ["Eeprom write FAILED pos ",dec EepromPosition," Value ",dec EepromValue,13,10]
        endif
    next EepromCounter
    read 200,DummyByte      'set pointer to place 200, if brown out or others happens, the current addresses won't be affected
return

Check_InputLink:
  if NrOfInputs<240 then
    if SwitchNr<8 then
      read SwitchNr,SwitchLink[SwitchNr]
      read 200,DummyByte      'set pointer to place 200, if brown out or others happens, the current addresses won't be affected
      if SwitchLink[SwitchNr]>239 then  'Switch not yet initialized
        SwitchLink[SwitchNr]=NrOfInputs
        EepromPosition=SwitchNr
        EepromValue=NrOfInputs
        gosub Write_eeprom_and_verify         
        'write SwitchNr,NrOfInputs 
        NrOfInputs=NrOfInputs+1                                  
      endif  
    endif
  else
    'Request Nr of Inputs
      QueueTxdByte0[QueueTxdPointer]=100 'Request Nr of Inputs from CAN controller
      QueueTxdByte1[QueueTxdPointer]=253
      QueueTxdByte2[QueueTxdPointer]=0
      QueueTxdByte3[QueueTxdPointer]=0     
      QueueTxdTime[QueueTxdPointer]=0          'sent message immeadiatly 
      QueueTxdRetries[QueueTxdPointer]=3       '3 retries
      QueueTxdNrBytes[QueueTxdPointer]=4  
      gosub Add_Txd_queue      
      'hserout2 ["Request Nr of Inputs ",13,10]     
  endif  
return

Press_switch:
  QueueTxdByte0[QueueTxdPointer]=1      'SID
  QueueTxdByte1[QueueTxdPointer]=1      'Message Type (switch press)
  QueueTxdByte2[QueueTxdPointer]=SwitchLink[SwitchNr]      'Switch number
  QueueTxdByte3[QueueTxdPointer]=0      'Press/Release
  QueueTxdTime[QueueTxdPointer]=0       'sent message immeadiatly
  QueueTxdRetries[QueueTxdPointer]=0    '0 retries
  QueueTxdNrBytes[QueueTxdPointer]=5    'Nr of bytes to be sent
  hserout2 ["Switch ",dec (SwitchNr+1)," ON (CSC=",dec COMSTATcounter,")",13,10]
  gosub Add_Txd_queue
  LedModeOld=LedMode    'After this led function, return to the previous led function
  LedMode=1             'Green Led ON for short period of time
  ResetLedMode=0        'Reset counter and after 2 minutes go back to LedMode=0
  LedFase=0
  StatusLedCounter=0    'Led Green ON immeadiatly
return

Release_Switch:
  QueueTxdByte0[QueueTxdPointer]=1
  QueueTxdByte1[QueueTxdPointer]=1
  QueueTxdByte2[QueueTxdPointer]=SwitchLink[SwitchNr]
  QueueTxdByte3[QueueTxdPointer]=1
  QueueTxdTime[QueueTxdPointer]=0
  QueueTxdRetries[QueueTxdPointer]=0    '0 retries
  QueueTxdNrBytes[QueueTxdPointer]=5    'Nr of bytes to be sent      
  hserout2 ["Switch ",dec (SwitchNr+1)," OFF",13,10]             
  gosub Add_Txd_queue
return

switch_control:
  if CheckSwitch=1 then
    SensorCounter=SensorCounter+1
    LedCounter[0]=LedCounter[0]+1
    LedCounter[1]=LedCounter[1]+1
    LedCounter[2]=LedCounter[2]+1
    LedCounter[3]=LedCounter[3]+1
    CanCounter=CanCounter+1
    ResetLedMode=ResetLedMode+1
    SensorToCounter=SensorToCounter+1
    'hier sensor
    if SensorSentCounter>0 then SensorSentCounter=SensorSentCounter-1
    I2CPowerCounter=I2CPowerCounter+1
    If StatusLedCounter>0 then StatusLedCounter=StatusLedCounter-1
    if CanTimer>0 then CanTimer=CanTimer-1  
    CheckSwitch=0
    if input1=1 and input1old=0 then
      'Low LedGreen
      SwitchNr=0
      gosub Check_InputLink
      gosub Check_SensorLink
      input1old=input1
      gosub Release_switch          
    endif 
    if input1=0 and input1old=1 then
      'Low LedGreen
      SwitchNr=0
      input1old=input1
      gosub Press_switch      
    endif      
    if input2=1 and input2old=0 then
      'Low LedGreen
      SwitchNr=1
      gosub Check_InputLink
      gosub Check_SensorLink          
      input2old=input2      
      gosub Release_switch      
    endif 
    if input2=0 and input2old=1 then
      'Low LedGreen
      SwitchNr=1
      input2old=input2
      gosub Press_switch           
    endif
    if input3=1 and input3old=0 then
      'Low LedGreen
      SwitchNr=2
      gosub Check_InputLink
      gosub Check_SensorLink          
      input3old=input3      
      Gosub Release_switch     
    endif 
    if input3=0 and input3old=1 then
      'Low LedGreen
      SwitchNr=2
      input3old=input3
      gosub Press_Switch           
    endif 
    if input4=1 and input4old=0 then
      'Low LedGreen
      SwitchNr=3
      gosub Check_InputLink
      gosub Check_SensorLink          
      input4old=input4      
      Gosub Release_switch     
    endif 
    if input4=0 and input4old=1 then
      'Low LedGreen
      SwitchNr=3
      input4old=input4
      gosub Press_Switch           
    endif 
    if input5=1 and input5old=0 then
      'Low LedGreen
      SwitchNr=4
      gosub Check_InputLink
      gosub Check_SensorLink          
      input5old=input5      
      Gosub Release_switch     
    endif 
    if input5=0 and input5old=1 then
      'Low LedGreen
      SwitchNr=4
      input5old=input5
      gosub Press_Switch           
    endif 
    if input6=1 and input6old=0 then
      'Low LedGreen
      SwitchNr=5
      gosub Check_InputLink
      gosub Check_SensorLink          
      input6old=input6      
      Gosub Release_switch     
    endif 
    if input6=0 and input6old=1 then
      'Low LedGreen
      SwitchNr=5
      input6old=input6
      gosub Press_Switch           
    endif
    'high LedGreen                
  endif    
return

Time_check_queue:   'Lower the counter for messages that haven't got receipt confirmation, when QueueTime=0 ->  Resent queue message
  if QueueTxdPointer>0 then
    for t=0 to QueueTxdPointer-1
      If QueueTxdTime[t]<255 and QueueTxdTime[t]>0 then
        QueueTxdTime[t]=QueueTxdTime[t]-1
        'hserout2 ["Queue has been lowered, ",dec t," ",dec QueueTxdTime[t],13,10]
        if QueueTxdTime[t]=0 then
          If QueueTxdRetries[t]>0 then
            QueueTxdRetries[t]=QueueTxdRetries[t]-1
            'hserout2 ["Time check queue nr ",dec t," ",dec QueueTxdRetries[t],13,10]
          else
            QueueTxdTime[t]=255  'Remove from queue
            'hserout2 ["Time check queue remove nr ",dec t,13,10]
          endif
        endif        
      endif
    next t
  endif  
return


Tx_CAN:
  if CanCounter>5 then
    CanCounter=0
    'hserout2 ["Checking queue ...",13,10]
    'gosub check_sending_queue
    gosub Time_check_queue
  endif
return

Rx_CAN:
'  if RecCan=1 and COMSTAT.0=0 then  'Buffer 0 full and Bus error free?
  if RecCan=1 then  'Buffer 0?
    RecCan=0
    gosub Check_receive_queue   
  endif
  if RXB1CON.7=1 then
    RXB1CON.7=0 'buffer is clear again   
  endif  
Return

init_CAN:
  'CAN BUS----------------------
  'Baudrate=Fosc/(2 x BRP x SEG)=125000 kbps  
  CANCON.7=1      'Request Config mode
  do until (CANSTAT.7=1 and CANSTAT.6=0 and CANSTAT.5=0) 'Wait until config mode is active
  loop
  'hserout2 ["Config mode enabled",13,10]
  BRGCON1=%00001111 '125kbps for 64Mhz
  'BRGCON1=%00001001 '125kbps for 40Mhz
  'BRGCON1=%00000011 '125kbps for 16Mhz   
  BRGCON2=%10011000 
  BRGCON3=%00000011
  'BRGCON1=%00010000 'BRP=16
  'BRGCON2=%10011000 'SEG=4
  'BRGCON3=%00000011  
  CIOCON.5=1
  CIOCON.4=0  
  ECANCON=%00000000  'Mode 0
  RXB0CON=%01100000  'Receive Buffer 0 is linked to acceptance filter 0
  RXB1CON=%01100010  'Receive Buffer 1 is linked to acceptance filter 2
  RXM0SIDL=%00000000 'Mask 0
  RXM0SIDH=%00000000
  RXM1SIDL=%00000000 'Mask 1
  RXM1SIDH=%00000000    
  RXF0SIDL=%00000000 'Filter 0, not used for the moment since Mask has been set to 0
  RXF0SIDH=%00000000
  RXF2SIDL=%00000000 'Filter 2, not used for the moment since Mask has been set to 0
  RXF2SIDH=%00000000    
  'TXB0SIDH=$10
  'TXB0SIDL=$10
  CANCON.7=0        'Normal Mode
  CANCON.6=0
  CANCON.5=0 
  do until (CANSTAT.7=0 and CANSTAT.6=0 and CANSTAT.5=0)  'Wait until normal mode is active
  loop
  'hserout2 ["Normal mode enabled",13,10]     
Return

Interprete_Serial: 'Interprete data coming from the RS485 bus
  if InterpreteSer1=1 then
    RCSTA1.4=0               'disable receiving serial 1  
    InterpreteSer1=0
    if pointerser1>6 then   
      if stackser1[0]="C" then  'Canbus module addressed 
      elseif stackser1[0]=0 and stackser1[1]=0 and stackser1[2]=0 and stackser1[3]=0 then    'Broadcast message
         if stackser1[4]="L" and stackser1[5]="L" then   'Bus in Live mode
           if mode="I" then 
             hserout2 ["Live Mode",13,10]
           endif  
           mode="L"
         endif
         if stackser1[4]="I" and stackser1[5]="I" then   'Bus in Initialize mode
           if mode="L" then 
             'low led_1
             hserout2 ["INIT Mode",13,10]
           endif
           mode="I"
         endif
      endif
    endif
    pointerser1=0
    RCSTA1.4=1            'enable receiving serial 1
  endif
return

'Check_IntI2CSensor:
'  if I2CExtSensor=0 then
'    if SensorCounter>5000 then
'      SensorCounter=0   
'      gosub read_sensor    
'    endif
'  endif      
'Return

Check_ExtI2CSensor:
  if I2CPowerReset=0 then  
    if I2CExtSensor=1 then
      if SensorCounter>8000 and SensorCheck=0 then
        SensorCheck=1 
        'delete
        'hserout2 ["Measure I2C sensor",13,10]  
        ReadExtSensor=1               'Read the external Honeywell sensor
        gosub Honeywell_measure       'First let the sensor measure
      endif
      if SensorCounter>11000 then
        SensorCheck=0
        SensorCounter=0
        'delete
        'hserout2 ["Read external I2C sensor",13,10]            
        gosub Honeywell_read   'Read the sensor
      endif  
    else
      if SensorToCounter>60000 then     'Check every 4 minutes
        SensorToCounter=0
        if SensorOk2=0 or SensorOk3=0 then
          'delete
          hserout2 ["Check if any new sensors can be found",13,10]
          gosub Check_Ext_sensor
        endif
      endif    
    endif
  endif  
return

Check_1wireSensor:
  if Sensor2_found=1 or Sensor3_found=1 then
    'if SensorCounter>5000 and ReadRom=0 then
    '  ReadRom=1
    '  hserout2 ["1Wire Read ROM",13,10]
    '  gosub Onewire_read_rom
    '  gosub Onewire_read_rom2
    'endif  
    if SensorCounter>7500 and ReadConv=0 then
      ReadConv=1
      hserout2 ["1Wire Temp Conv",13,10]
      gosub Onewire_temp_Conv
      gosub Onewire_temp_Conv2    
    endif
    if SensorCounter>10000 and ReadTemp=0 then
      ReadTemp=1
      hserout2 ["1Wire Read Temp",13,10]
      gosub Onewire_Read_temp
      gosub Onewire_Read_temp2
    endif
    if SensorCounter>10200 and CheckReset=0 then
      CheckReset=1
      hserout2 ["1Wire reset ",dec Sensor2_found," ",dec SensorOk2," ",dec Sensor3_found," ",dec SensorOk3,13,10]  
      if Sensor2_found=1 and SensorOk2=0 then       'reset is needed since sensor doesn't respond anymore
        gosub Output1wire_OFF
      elseif Sensor3_found=1 and SensorOk3=0 then   'reset is needed since sensor doesn't respond anymore
        gosub Output1wire_OFF
      else                                          'everything is OK
        SensorCounter=0
        ReadTemp=0
        ReadRom=0
        ReadConv=0
        CheckReset=0     
      endif
    endif
    if SensorCounter>30000 then                     'Switch sensors ON again 
      hserout2 ["1Wire Output ON",13,10]
      SensorCounter=0
      ReadTemp=0
      ReadRom=0
      ReadConv=0
      CheckReset=0
      gosub Output1wire_ON  
    endif
  endif          
return

Output1wire_OFF:
  low I2CExtEnable
  low PullUp1
  low PullUp2
  Low OneWire
  Low OneWire2
  high ExternalPowerOff
  hserout2 ["1wire power OFF",13,10]
return

Output1wire_ON:
  high PullUp1
  high PullUp2
  high OneWire
  high OneWire2
  low ExternalPowerOff
  hserout2 ["1wire power ON",13,10]
  pause 3
  gosub check_ext_sensor
return

check_SerialErrors:
  if RCSTA1.2=1 then  'frame error bit
    x=RCREG1
  endif
  if RCSTA1.1=1 then  'Overrun Error bit
    RCSTA1.4=0    'disable receiver
    pause 2
    RCSTA1.4=1    'enable receiver
  endif
return

'------------------------------------------------------------------------------
' I2C subroutines
'------------------------------------------------------------------------------

Check_Ext_Sensor:
  if ExternalPowerOff=0 then      'only when external power is ON
    SensorOk1=0
    SensorOk2=0
    SensorOk3=0  
    'hserout2 ["Check if DS1820 are connected",13,10]
    TRISB=%11001100
    low I2CExtEnable
    high PullUp1
    high PullUp2
    gosub Onewire_read_rom
    gosub Onewire_read_rom2
    'delete
    if Sensor2_found=1 then
      hserout2 ["DS1820 on first output found",13,10]
      I2CExtSensor=0
      sensorcounter=7001
      SensorOk2=1
    endif        
    if Sensor3_found=1 then
      hserout2 ["DS1820 on second output found",13,10]
      I2CExtSensor=0
      sensorcounter=7001
      SensorOk3=1
    endif  
    if Sensor2_found=0 and Sensor3_found=0 then  'only check external i2c when no ds1820 are connected
      low externalPowerOff
      'delete
      'hserout2 ["Check if external i2c sensor is connected and ok",13,10]
      I2CExtSensor=0
      TRISB=%11001111
      high I2CExtEnable
      high PullUp1
      high PullUp2  
      gosub Honeywell_measure
      SensorCounter=8005
      SensorCheck=1    
      if Err=0 then
        hserout2 ["External I2c Sensor found and Ok",13,10]
        I2CExtSensor=1
        SensorOk1=1
        Sensor2_found=0
        Sensor3_found=0
      endif
    endif
  else
    SensorToCounter=25000  
  endif   
return

'Reset_I2C_basic:
'  hserout2 ["Reset i2c Soft",13,10]
'  SensorError=0
'  'i2cerror=0     
'  PIE1.3=0                                'disable interrupt  
'  SSPCON1.5=0                             'disable i2c      
'  TRISC=%10100000
'  high SDA
'  high SCL
'  pauseus 10
'  for i=0 to 8
'    pauseus 10
'    low SDA
'    pauseus 10
'    low SCL
'    pauseus 10
'    high SDA
'    pauseus 10
'    high SCL    
'  next i
'  low SCL
'  low SDA
'  TRISC=%10011000   
'  SSPADD.0=0                              '?kHz
'  SSPADD.1=0
'  SSPADD.2=0
'  SSPADD.3=1
'  SSPADD.4=1
'  SSPADD.5=0
'  SSPADD.6=0
'  SSPCON1=%00101000                       'turn on MSSP and set for master mode i2c 
'  PIR1.3=0                                'clear interrupt flag
'  PIE1.3=1                                'enable interrupt    
'  i2cmode=0  
'  i2cInt=0    
'return

Reset_I2C_power:
  hserout2 ["Reset i2c Hard",13,10]
  i2cerror=0
  PIE1.3=0                                'disable interrupt  
  SSPCON1.5=0                             'disable i2c      
  TRISC=%10100000
  low SDA
  low SCL  
  high ExternalPowerOff
  low Powersensor
  hserout2 ["I2C power off",13,10]
  I2CPowerReset=1
  I2CPowerCounter=0 
return

I2C_Power_on:      
  TRISC=%10011000   
  SSPADD.0=1                              '?kHz
  SSPADD.1=1
  SSPADD.2=1
  SSPADD.3=1
  SSPADD.4=1
  SSPADD.5=1
  SSPADD.6=1
  SSPCON1=%00101000                       'turn on MSSP and set for master mode i2c 
  PIR1.3=0                                'clear interrupt flag
  PIE1.3=1                                'enable interrupt    
  i2cmode=0  
  i2cInt=0
  high PowerSensor                      'Power onboard Sensor on
  low ExternalPowerOff
  SensorCounter=7000
  I2CPowerReset=0
  hserout2 ["I2C power on",13,10]           
Return

Check_i2c_error:
  if SensorOk2=0 and SensorOk3=0 then         'Only do this when no DS1820 have been found
    'hserout2 ["PC=",dec I2CPowerCounter,13,10]
    if err=1 then
      err=0
      if i2cerror=2 or SensorError>6 then
        gosub Reset_I2C_power
      elseif i2cerror>6 then  
        gosub Reset_I2C_power
      endif
    endif
    if I2CPowerReset=1 and I2CPowerCounter>14000 then
      'hserout2 ["PC=",dec I2CPowerCounter,13,10]
      I2CPowerReset=0
      I2CPowerCounter=0
      gosub I2C_Power_on
    endif  
  endif  
return

'read_Sensor:
'  if SensorOk2=0 and SensorOk3=0 and I2CExtSensor=0 then
'    if OnBoardSensorOk=1 then
'      'delete
'      hserout2 ["Read internal I2C sensor",13,10]
'      i2ccont=%10000001
'      ReadExtSensor=0    'Read the onboard sensor
'      gosub Honeywell_read
'    endif
'  endif    
'return

'write_Sensor:
''  if LedDriverOk=1 then
'    i2ccont=%10000000
'    Frame[0]=2   'configuration of HDC1000
'    Frame[1]=%00010110
'    Frame[2]=%00000000 
'    gosub Writing_Frame
''  endif  
'return

check_i2c_acknowledge:
  if SSPCON2.6=0 then 'Acknowledge received from slave
    i2cAck=1 'Acknowledge received
    SSPCON2.6=1
  else
    i2cAck=0
  endif 
return

'delete
'Test_I2C_address:
'  ReadExtSensor=1
'  I2cExtEnable=1
'  for i=0 to 255
'   hserout2 ["Test response i2c device with address ",bin8 i,13,10]
'   i2ccont=i
'   gosub start_reading_i2c
'   pause 10
'  next i 
'return

Honeywell_measure:
  'delete
  i2ccont=%01001111
  hserout2 ["Measure Honeywell ",bin8 i2ccont," ",dec Frame[0]," ",dec Frame[1]," ",dec Frame[2],13,10] 
  i2cint=1
  i2cmode=1
  TMR1L=0
  TMR1H=0  
  'T3CON.0=1  'start timer3
  T1CON.0=1  'timer 1 enabled 
  i2ccont.bit0=0    'WRITE  
  while (i2cMode>0)   
    if i2cMode=1 then 'generate start condition
      'hserout2 ["Start",13,10]
      SSPCON2.0=1
      pauseus 2
    endif
    if i2cMode=2  then 'shift out i2c control byte
      'hserout2 ["Shift",13,10]
      SSPBUF=i2ccont
      i2cmode=3
    endif
    if i2cMode=4 then 'check acknowledge and shift out additional write bytes   
      gosub check_i2c_acknowledge
      if i2cAck=1 then
        'hserout2 ["Stop",13,10]
        pauseus 2
        i2cMode=5
        SSPCON2.2=1   'Sent Stop condition
      endif     
    endif
    if i2cMode=6 then 'end transmission
      'hserout2 ["end",13,10]       
      i2cMode=0
      T1CON.0=0       'stop timer1
      err=0
      i2cerror=0 
    endif 
  wend
return

'Start_Reading_I2C:
'  'delete
'  hserout2 ["Start reading I2C ",bin8 i2ccont," ",dec Frame[0]," ",dec Frame[1]," ",dec Frame[2],13,10] 
'  i2cint=1
'  i2cmode=1
'  TMR1L=0
'  TMR1H=0  
'  'T3CON.0=1  'start timer3
'  T1CON.0=1  'timer 1 enabled 
'  i2ccont.bit0=0    'WRITE  
'    while (i2cMode>0)   
'      if i2cMode=1 then 'generate start condition
'        SSPCON2.0=1
'      endif
'      if i2cMode=2  then 'shift out i2c control byte
'        SSPBUF=i2ccont
'        i2cmode=3
'      endif
'      if i2cMode=4 then 'check acknowledge and shift out additional write bytes   
'        gosub check_i2c_acknowledge
'        if i2cAck=1 then
'          if ReadExtSensor=0 then   'Don't do this when you're reading the external i2c Honeywell sensor
'            pause 1
'            i2cMode=5
'            SSPBUF=Frame[0]
'          else
'            i2cMode=5
'            SSPCON2.2=1   'Sent Stop condition
'          endif     
'        endif
'      endif
'      if i2cMode=6 then 'end transmission       
'        i2cMode=0
'        T1CON.0=0       'stop timer1
'        err=0
'        i2cerror=0 
'      endif 
'  wend
'return

Honeywell_read:
  'delete
  hserout2 ["Start reading Temp/hum ",bin8 i2ccont," ",dec Frame[0]," ",dec Frame[1]," ",dec Frame[2],13,10]
  i2ccont=%01001111
  i2cint=1
  i2cmode=1
  TMR1L=0
  TMR1H=0  
  T1CON.0=1  'timer 1 enabled     
  i2ccont.bit0=1    'READ   
  while (i2cMode>0)  
    'if i2cInt=1 then   'i2c chip is ready for next instruction
      i2cInt=0
      pauseus 20
      if i2cMode=1 then 'generate start condition
        SSPCON2.0=1
      endif
      if i2cMode=2  then 'shift out i2c control byte
        'pause 1
        'pauseus 20
        SSPBUF=i2ccont
      endif
      if i2cMode=3 then
        'pauseus 20
        'pause 1      
        SSPCON2.3=1    'enable receiving 
      endif           
      if i2cMode=4 then 'check acknowledge and receive data 
        if SSPSTAT.0=1 then 'Buffer full
          i2cdata[0]=SSPBUF
          'pauseus 20
          SSPCON2.5=0     'ACK, not NACK                    
          SSPCON2.4=1     'Sent Ack
          'hserout2 ["BF 0 ",bin8 i2cdata[0],13,10]
        endif   
      endif
      if i2cMode=5 then
        'pauseus 20      
        SSPCON2.3=1    'enable receiving 
      endif      
      if i2cMode=6 then 'check acknowledge and receive data
        if SSPSTAT.0=1 then 'Buffer full 
          i2cdata[1]=SSPBUF
          'pauseus 20
          SSPCON2.5=0     'ACK, not NACK
          SSPCON2.4=1     'Sent Ack          
          'hserout2 ["BF 1 ",bin8 i2cdata[1],13,10] 
          'i2cmode=6
        endif
      endif     
      if i2cMode=7 then
        'pauseus 20      
        SSPCON2.3=1    'enable receiving
      endif      
      if i2cMode=8 then 'check acknowledge and receive data 
        if SSPSTAT.0=1 then 'Buffer full
          i2cdata[2]=SSPBUF
          'pauseus 20
          SSPCON2.5=0     'ACK, not NACK          
          SSPCON2.4=1     'Sent Ack
          'i2cmode=7
          'hserout2 ["BF 2 ",bin8 i2cdata[2],13,10]
        endif   
      endif
      if i2cMode=9 then
        'pauseus 20      
        SSPCON2.3=1    'enable receiving 
      endif       
      if i2cMode=10 then 'check acknowledge and receive data
        if SSPSTAT.0=1 then 'Buffer full 
          i2cdata[3]=SSPBUF
          'pauseus 20
          SSPCON2.5=1     'NACK, not ACK          
          SSPCON2.4=1     'Sent NAck
          'i2cmode=8
          'hserout2 ["BF 3 ",bin8 i2cdata[3],13,10] 
        endif
      endif             
      if i2cMode=11 then 'sent stop
        'pauseus 20   
        SSPCON2.2=1     
      endif
      if i2cMode=12 then 'end transmission 
        i2cMode=0
        T1CON.0=0       'stop timer1
        err=0
        i2cerror=0
        'if ReadExtSensor=1 then
          Tempword=i2cdata[2]*64
          'hserout2 ["I2Cdata*64=",dec Tempword,13,10]
          x=(i2cdata[3]>>2)
          'hserout2 ["I2Cdata>>2=",dec x,13,10]
          Tempword=Tempword+x
          Tempword2=Tempword//99
          Tempword=(tempword/99)-40
          x=i2cdata[0]
          'hserout2 ["statusbits ",dec x.bit7," ",dec x.bit6,13,10]
          i2cdata[0]=i2cdata[0]&%00111111
          z=(((i2cdata[0]*256)+i2cdata[1])/164)
          u=(((i2cdata[0]*256)+i2cdata[1])//164)        
        'else
        '  x=(((i2cdata[0]*256)+i2cdata[1])/397)-40
        '  y=(((i2cdata[0]*256)+i2cdata[1])//397)
        '  z=(((i2cdata[2]*256)+i2cdata[3])/655)
        '  u=(((i2cdata[2]*256)+i2cdata[3])//655)
        '  SensorOk1=1
        'endif
        hserout2 ["I2C data: ",dec i2cdata[0]," ",dec i2cdata[1]," ",dec i2cdata[2]," ",dec i2cdata[3],13,10]
        hserout2 ["Temp=",dec tempword,",",dec tempword2, " Hum=",dec z,",",dec u,"%",13,10]
        if Tempword>80 then
          hserout2 ["wrong temperature ",dec SensorError,13,10]
          SensorError=SensorError+1
        else
          SensorError=0
          if tempword2<25 then
            x=((tempword.byte0+32)*2)
          elseif tempword2>24 and tempword2<75 then
            x=((tempword.byte0+32)*2)+1
          else
            x=((tempword.byte0+32)*2)+2
          endif   
          'if y<100 then
          '  if y>9 then
          '    x=((x+32)*2)+(y/50)
          '  else
          '    x=((x+32)*2)+(y/5)
          '  endif    
          'else
          '  x=((x+32)*2)+(y/500)
          'endif
        endif      
        hserout2 ["System value=",dec x," -> ",dec (x/2)-32,".",dec (x//2)*5,13,10]
        if sensorerror=0 then
          if x>(TempOld-4) and x<(TempOld+4) then  'Maximum 2 degree different between to measurements
            Temperature=x
            'delete
          else
            hserout2 ["Temp difference too big, ignore value ",13,10]
          endif
          TempOld=x
        endif    
        'a=(x/2)-32
        'b=(x//2)*5                                                                      
        'hserout2 [" ",dec a,",",dec b,13,10]
        if u<100 then
          if u>9 then
            v=(z+(u/50))*2
          else
            v=(z+(u/5))*2
          endif  
        else
          v=(z+(u/500))*2
        endif
        if v<200 then
          'if v>(HumidityOld-4) and v<(HumidityOld+4) then  'Maximum 4% different between to measurements 
            Humidity=v
          'else
          '  hserout2 ["Humidity difference too big, ignore value",13,10]
          'endif
          HumidityOld=v   
        else
          if u>0 then  'Humidity higher then 100%
            hserout2 ["wrong Humidity ",Dec SensorError,13,10]
            SensorError=SensorError+1
          else
            Humidity=200
          endif
        endif
        i2cMode=0               
      endif   
  wend  
return

'Reading_Config:
'  i2ccont=%10000001
'  'delete
'  hserout2 ["Reading config ",bin8 i2ccont," ",dec Frame[0]," ",dec Frame[1]," ",dec Frame[2],13,10]
'  Frame[0]=2    'Pointer register
'  gosub Start_Reading_I2C
'  i2cint=1
'  i2cmode=1
'  TMR1L=0
'  TMR1H=0  
'  'T3CON.0=1  'start timer3
'  T1CON.0=1  'timer 1 enabled     
'  i2ccont.bit0=1    'READ   
'  while (i2cMode>0)  
'    if i2cInt=1 then   'i2c chip is ready for next instruction
'      i2cInt=0
'      if i2cMode=1 then 'generate start condition
'        SSPCON2.0=1
'      endif
'      if i2cMode=2  then 'shift out i2c control byte
'        SSPBUF=i2ccont
'      endif
'      if i2cMode=3 then
'        SSPCON2.3=1    'enable receiving
'      endif           
'      if i2cMode=4 then 'receive data 
'        i2cdata[0]=SSPBUF
'        i2cMode=5
'        gosub end_i2c_2 
'      endif
'      if i2cMode=5 then 'receive data 
'        i2cdata[1]=SSPBUF
'        i2cMode=6
'        gosub end_i2c_2 
'      endif        
'      if i2cMode=6 then 'sent stop   
'        SSPCON2.2=1     
'      endif
'      if i2cMode=7 then 'end transmission 
'        i2cMode=0
'        T1CON.0=0       'stop timer1
'        err=0
'        i2cerror=0
'        'hserout2 ["I2C Data - Config: ",bin8 i2cdata[0]," ",Bin8 i2cdata[1],13,10]
'      endif
'    endif
'    end_i2c_2:   
'  wend  
'return

'Writing_Frame:
'  'delete
'  hserout2 ["Writing Frame I2C ",bin8 i2ccont," ",dec Frame[0]," ",dec Frame[1]," ",dec Frame[2],13,10]
'  i2ccont.bit0=0    'Write
'  i2cint=1
'  i2cmode=1
'  TMR1L=0
'  TMR1H=0  
'  'T3CON.0=1  'start timer3
'  T1CON.0=1  'timer 1 enabled 
'  while (i2cMode>0)   
'      if i2cMode=1 then 'generate start condition
'        SSPCON2.0=1
'      endif
'      if i2cMode=2  then 'shift out i2c control byte
'        SSPBUF=i2ccont
'      endif
'      if i2cMode=3 then 'check acknowledge and shift out additional write bytes   
'        gosub check_i2c_acknowledge
'        if i2cAck=1 then
'          SSPBUF=Frame[0] 
'        endif
'      endif
'      if i2cMode=4 then 'check acknowledge and shift out additional write bytes   
'        gosub check_i2c_acknowledge
'        if i2cAck=1 then
'          SSPBUF=Frame[1] 
'        endif
'      endif
'      if i2cMode=5 then 'check acknowledge and shift out additional write bytes   
'        gosub check_i2c_acknowledge
'        if i2cAck=1 then
'          SSPBUF=Frame[2] 
'        endif
'      endif    
'      if i2cMode=6 then 'sent stop 
'        gosub check_i2c_acknowledge
'        if i2cAck=1 then
'          SSPCON2.2=1 
'        endif             
'      endif
'      if i2cMode=7 then 'end transmission 
'        i2cMode=0
'        T1CON.0=0       'stop timer1
'        err=0
'        i2cerror=0
'      endif 
'  wend         
'return
   
End
